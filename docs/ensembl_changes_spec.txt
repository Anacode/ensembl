ENSEMBL - API Change Specification
==================================

INTRODUCTION
------------

This document is intended as an outline of possible changes to the current 
incarnation of the EnsEMBL database schema and Perl API. This document is 
evolving and will hopefully enable us to develop a plan for the progression 
of the EnsEMBL API. Nothing is finalized and everything is open to change.
Many of the proposed alterations may need to be phased in over time or may 
never occur at all.


REVISION HISTORY
----------------

Graham Mcvicker - July  9, 2003 - Created
Graham McVicker - July 22, 2003 - Added Haplotype Spec.

GOALS
-----
-A cleaner, more intuitive API
-A more general schema able to better capture divergent assembly types
-More flexibility with regards to assembly related data such as haplotypes,
 PARs, WGS assemblies etc.

SCHEMA MODIFICATIONS
--------------------

Proposed New/Modified Tables:
-----------------------------

  seq_region
  -------
  seq_region_id  int
  name        varchar
  type        varchar (or maybe enum)
  length      int


  dna
  ---
  seq_region_id  int
  sequence    varchar


  assembly
  --------
  seq_region_id_assembled  int
  seq_region_id_component  int
  component_start       int
  component_end         int
  assembled_start       int
  assembly_end          int
  orientation           tinyint (or enum?)

  gene
  ----
  For faster retrieval and retrieval independently of transcripts and 
  exons genes will also have a seq_region_id, seq_region_start and seq_region_end.
  
  gene_id          int
  type             varchar
  analysis_id      int
  seq_region_id       int
  seq_region_start    int
  seq_region_end      int
  seq_region_strand   int (or enum?)
  transcript_count   - (is this necessary? - probably can go)
  display_xref_id


  transcript
  ----------
  For faster retrieval and retrieval independently of genes and exons
  transcripts will also have a seq_region_id, seq_region_start and seq_region_end.
  The translation_id will be removed, translations will point to transcripts
  instead (and pseudogenes will have no translation).  Prediction transcripts 
  will now be stored as normal transcripts without genes.  In order to 
  distinguish between transcript types an analysis id will be necessary.
  Transcripts which do not have an associated gene will have a NULL value for
  the gene_id.  An alternative solution would be to construct a gene_transcript
  table in a similar style as the existing exon_transcript table.

  transcript_id    int
  gene_id          int (NULLABLE)
  exon_count       int   - (is this necessary?)
  seq_region_id       int
  seq_region_start    int
  seq_region_end      int
  seq_region_strand   int (or enum?)
  display_xref_id  int
  analysis_id      int

  
  translation
  -----------
  Translations now reference transcripts rather than transcripts referencing
  a single (or no) translation.  This allows for more elegant handling of 
  pseudogenes (where there is no translation) and also can be used to supply
  multiple translations for a single transcript (e.g. polycistronic genes).

  translation_id   int
  transcript_id    int
  start_exon_id    int
  end_exon_id      int
  seq_start        int
  seq_end          int



  all feature tables
  ------------------
  All feature tables would now have seq_region_id, seq_region_start, seq_region_end,
  seq_region_strand instead of contig_id, contig_start, contig_end
  This includes the repeat_feature, simple_feature, dna_align_feature,
  protein_align_feature, exon, marker_feature,
  and qtl_feature tables.

  
Removed Tables
--------------

  prediction_transcript
  ---------------------
  PTs are now stored as ordinary transcripts without genes.  They should 
  probably be computed in chromosomal coordinates instead of contig 
  coordinates.
  

  contig
  ------
  Contigs are no longer needed.  They are stored as entries in the seq_region
  table with type 'contig'.  The embl_offset and clone_id will not be
  necessary as their relationship to clones can be described by the 
  assembly table.

  clone
  -----
  Clones are no longer needed.  Clones are stored as entries in the seq_region 
  table with type 'clone'.  The htg_phase, created and modified timestamps will
  be discarded as they are no longer maintained anyway.  The embl_acc, version,
  and embl_version columns are redundant and will also be discarded.  Versions
  can simply be appended onto the end of the name with a '.'.

  chromosome
  ----------
  This table is no longer needed.  Chromosomes can be stored in the 
  seq_region table with type 'chromosome'.


META INFORMATION
----------------

Considerable more meta information will have to be stored in the core
databases in order for the general approach to be maintained.  It may 
be satisfactory to store this information in the existing meta table, 
or it may be better to create a meta_assembly table that is more specific.

This includes the following:

  The seq_region type (coordinate system) that every type of feature is stored
  in.  This may be based on either logic_names, or upon table names.

  The top-level seq_region type (coordinate system). For human
  this would be 'chromosome'.  For briggsae this may be something like
  'scaffold' or 'super contig'.  This information would be used to construct
  the web display and would possible be the default coordinate system when 
  a coordinate system is unspecified by a user.

  The sequence seq_region type.  This describes the dna frag type (coordinate 
  system) at which the sequence is stored at.  For example in human this would 
  be at the contig or clone level.  

  The assembly relationships between coordinate systems.  For example  
  the clone, chromosome and nt_contig coordinate systems may all be constructed 
  from the contig coordinate system:
    contig -> clone
    contig -> chromosome
    contig -> nt_contig
  Or there may be a more hierarchical approach:
    contig    -> clone
    clone     -> nt_contig
    nt_contig -> chromosome

  The names of the allowable coordinate systems.  This would allow for 
  quick validation of API requests and provide a list that could be used
  by the website for coordinate system selection.


API CHANGES
-----------

Slice
-----
  Slice methods chr_start, chr_end, chr_name will be renamed start, end, 
  frag_name.

  A new slice method 'coord_system' will be added and will denote the type
  of dna_frag the slice is built on.

  Slices will represent a region on a seq_region as opposed to a region on a
  chromosome.  Slices will be immutable (i.e. their attributes will not be
  changeable).  A new slice will have to be created if the attributes are to
  be changed.

  The following attributes will therefore define a unique slice:
  coord_system  (e.g. 'chromosome' or 'clone')
  frag_name     (e.g. 'X' or 'AL035554.1')
  start         (e.g. 1000000 or 1)
  end           (e.g. 2000001 or 800)
  strand        (e.g. 1 or -1)

  The name method will return the above values joined by a ':' delimiter, and
  will not be settable:
  e.g.  'chromosome:X:1000000:2000001:1' or 'clone:AL035554.1:1:800:-1'
  This value can be used as a hashvalue that uniquely defines a slice.

  The concept of an 'empty' slice will no longer exist.

  The get_tiling_path method will have to be implemented differently for the
  new system.  It will take a coord_system string as an argument and rather 
  than returning a list of Tile objects it will return a listref of triplets 
  containing a start int, and end int, and a 'to' slice object.  The following 
  is an example of how this method would be used ($clone is a reference to a 
  slice object in the clone coordinate system):

    my $clone_path = $slice->get_tiling_path('clone');

    foreach my $tile (@$clone_path) {
      my ($start, $end, $clone) = @$tile;
      print $slice->frag_name, ':', $start, '-', $end , ' -> ',
            $clone->frag_name, ':', $clone->start, '-', $clone->end, 
            $clone->strand, "\n";
    }


Tile
----
  The tile object will no longer be necessary.


SliceAdaptor
------------
  The Slice adaptor must provide a method to fetch a slice via its coordinate
  system, frag_name, start, end, and strand.  The old, commonly used method
  fetch_by_chr_start_end can be altered to simply chain to this new method
  as can most other SliceAdaptor methods.

  Another method which will be necessary with the disapearence of the Clone,
  RawContig and Chromosome adaptors is the one which allows for all slices
  of a certain type to be retrieved.  For example it is often necessary to 
  retrieve all chromosomes, or clones for a species.  This method could be
  named fetch_all_by_coord_system or something similar.

  Proposed Method Names and Signatures
  ------------------------------------
    Slice fetch_by_region(coord_system, name)
    Slice fetch_by_region(coord_system, name, start)
    Slice fetch_by_region(coord_system, name, start, end)
    Slice fetch_by_region(coord_system, name, start, end, strand)
    listref of Slices fetch_all(coord_system)
  
RawContig
---------
  The RawContig object is no longer necessary with the new system.  RawContigs
  are replaced by Slices with coord_system = 'contig'. In the interests of 
  backwards compatibility the RawContig class can stick around for a while,
  as a minimal implmentation inheriting from the Slice class.


RawContigAdaptor
----------------
  The RawContigAdaptor is no longer necessary.  The RawContigAdaptor is 
  replaced by the SliceAdaptor.  For backwards compatibility a minimal 
  implementation of the RawContigAdaptor can remain which inherits from the 
  SliceAdaptor.

Clone
-----
  The Clone object is no longer necessary in the new system.  Clones are 
  replaced by Slices with coord_system = 'clone'. For backwards compatibility
  a minimal implementation can remain which inherits from the Slice object.

CloneAdaptor
------------
  The CloneAdaptor object is no longer necessary in the new system.  The
  CloneAdaptor is replaced by the SliceAdaptor.  For backwards compatibility
  a minimal implementation can remain which inherits from the Slice object.

Chromosome
----------
  The Chromosome object is no longer necessary in the new system.  The
  Chromosome is replaced by Slices with coord_system = 'chromosome' (or
  whatever the top level seq_region type is for that species).  For backwards
  compatibility a minimal implementation can remain which inherits from the
  Slice object.  Statistical information (e.g. known genes, genes, snps) that 
  was on chromosomes should be possible to calculate directly from the 
  map_density table with very little impact on performance.

ChromosomeAdaptor
-----------------
  The Chromosome object is no longer necessary in the new system. The 
  ChromosomeAdaptor is replaced by the SliceAdaptor.  For backwards 
  compatibility a minimal implementation which inherits from the SliceAdaptor
  can remain.


Root
----
  Every class in the current EnsEMBL perl API inherits directly or indirectly
  from Bio::EnsEMBL::Root.  This inheritance is almost exclusively for the
  following following three methods:
    throw
    warn
    _rearrange

  Nothing is gained by implementing this relationship as inheritance, and there
  are several disadvantages:
    (1) Everything must inherit from this class to use those 3 object methods.
    This can result in patterns of multiple inheritance which are generally
    considered to be a bad thing.

    (2) It is not possible to use the throw, warn or rearrange method within
    the constructor until the object is blessed.  Blessing the object first
    and then calling rearrange to extract named arguments is slower because
    the blessed hash needs to be expanded as more keys are added and several
    key access/value assignements may need to be performed.

    (3) Objects become larger and object construction becomes slightly slower
    because constructors traverse an additional level of inheritance.

  A better approach would be to make the methods static and create a static
  utility class that exported the methods.  Note, however, that warn is builtin
  perl function and it may be better if we renamed this method.
  They could then be used as follows:

  #
  # OLD STYLE
  #
  package Old;

  use Bio::EnsEMBL::Root;

  @ISA = qw(Bio::EnsEMBL::Root);

  sub new {
    my $caller = shift;
    my $class = ref($caller) || $caller;

    $self = $class->SUPER::new(@_);
    
    my ($start, $end) = $self->_rearrange(['START', 'END'], @_);

    if(!defined($start) || !$defined($end)) {
      $self->throw('-START and -END arguments are required');
    }

    $self->{'start'} = $start;
    $self->{'end'}   = $end;

    return $self;
  }

  #
  # NEW STYLE
  #
  package New;

  use Bio::EnsEMBL::Util::Exception qw(throw warn);
  use Bio::EnsEMBL::Util::Argument  qw(rearrange);

  sub new {
    my $caller = shift;

    my $class = ref($caller) || $caller;

    my ($start, $end) = rearrange(['START', 'END'], @_);

    if(!defined($start) || !defined($end)) {
      throw('-START and -END arguments are required');
    }

    return bless {'start' => $start, 'end' => $end}, $class;
  }



Storable Base Class
-------------------
  Almost all business objects in the EnsEMBL system are storable in the db
  and the ones which are always require 2 methods: dbID and adaptor.  It would
  make sense in order to reduce code duplication to have all storable objects
  inherit from a Storable base class which implemented these.

Features
--------
  All features should inherit from a base class that implements common feature
  functionality.  Presently this role is filled by the bloated SeqFeature class
  which inherits from Bio::SeqFeature and Bio::SeqFeatureI etc.  I think that
  this class can be ditched in favour of a smaller, less complicated 
  implementation named Feature.  To make classes more polymorphic in general,
  the gene, and transcript objects should now also inherit from the Feature
  class.  This class should implement the following
  core methods common to all features:

    start
    end
    strand
    slice (formerly named contig/entire_seq/etc.)
    transform
    transfer
    map
    
  The feature class would likely inherit from the Storable base class and
  thereby inherit the following methods:

    adaptor
    dbID

  The signature and behaviour of the transform method will be changed.  The
  existing method works differently depending on the arguments passed.  The 
  existing method behaves in the manor described for each of the different
  method signatures:

    OLD transform(no arguments)
    -----------------------
      Transforms from slice coordinates to contig coordinates.  The feature
      is changed in place and returned.  If the feature already is in contig
      coordinates an exception is thrown.  The feature may be split into two
      features in which case both features are returned (not sure if one of
      them is transformed in place).  Some features are not permitted to be
      split in two in which case an exception is thrown? (not sure) if it is
      to be split accross contigs.

    OLD transform(slice)
    ----------------
      If the feature is already in slice coordinates and the slice is on the
      same chromosome the features coordinates are simply shifted.  If the
      feature is already in slice coordinates but on a different chromosome
      an exception is thrown.
      It the feature is in contig coordinates and the slice is not empty then
      it is transformed onto the new slice (or an exception is thrown if the 
      transform would cause the feature to end up on a different chromosome
      than the slice).  If the feature is in contig coordinates and the
      slice is an empty slice the feature is transformed into chromosomal
      coordinates and placed on a newly created slice of the entire chromosome.

    The new transformation will have only a single valid signature and will
    split it's responsibilities with the new transfer method.  The transfer 
    method will transfer a feature onto another slice, whereas the transform
    method will simply convert coordinate systems.  As well transform will 
    NOT transform features in place but will rather return the newly 
    transformed feature as a new object:
    
    transform(coord_system)
    -----------------------
      Takes a single string specifying the new coord system. If the coord
      system is not valid an exception is thrown. If the coord system is the
      same coord system as the feature is currently in a new feature that is
      a copy of the old one will still be returned.  This will also retrieve
      a slice which is the entire span of the region of the coordinate system
      that this feature is being transformed to.  For example transforming
      an exon in raw contig coordinates to one in chromosomal coodinates
      will place the exon on a slice of an entire chromosome.  If a feature
      spans a boundary in the coordinate system, undef is returned by the
      method instead.

    transfer(slice)
    ----------------
      Shifts a feature from one slice to another.  If the new slice is in the
      same coordinate system but different frag_name (e.g. both chromosomal but
      different chromosomes) an exception is thrown.  If the new slice is
      in a different coordinate system then the transform method is called 
      first.  If the feature would be split accross a boundary undef is
      returned instead.  After the transform there follows a potentially 
      move, if the slice does not cover the full fragment.
      If there is no transform call necessary, the feature is copied and then
      moved.

    move( start, end, strand )
    --------------------------
      In place change of the coordinates of the feature. It will stay on the 
      same slice.

    map(coord_system)
    -----------------
      Performs the mapping of a feature from one coordinate system to another
      but rather than returning a feature a list of coordinate/gap objects is
      returned. This enables people to construct their own mappings even if
      the feature is split accross boundaries in a lower level coordinate
      system.
 

StickyExon
----------
  The sticky exon object will not be present in the new system.  It does not
  make sense to define features in a coordinate system where they are simply 
  not present.  Exons are calculated in chromosomal coordinates and they
  will generally be retrieved in the same coordinates system.  It will
  of course be possible to still retrieve exons in contig coordinates but only
  is they are fully defined on the contigs of interest.
  The split coordinates can be obtained through a call to the base feature 
  method map().


AssemblyMapper
--------------
  The assembly mapper object will have to become more clever.  It must be
  able to load a mapper with using 'coordinate system chaining'.  Currently
  the mapper is loaded with coordinates read directly from the assembly table
  but this will not always be possible.  For example to map from the NT contig
  coordinate system to the clone coordinate system the mapper will have to 
  do the following:
  NTContig -> Contig -> Clone

  In the above example the assembly mapper would have do the following:

  (1) Create a mapper object between the NTContig and Contig region
  (2) Create a mapper object between the Contig and Clone region
  (3) Create and return a third mapper constructed from the sets of mappings
  generated by the intermediate mappers.

  As an intermediate implementation step it would be possible to leave the
  AssemblyMapper almost as is and to require explicit mappings between all 
  coordinate systems of intereset to be present in the assembly table.


FeatureAdaptors
---------------
  Most FeatureAdaptors should inherit from the BaseFeature adaptor.  As a 
  minimum feature adaptors should have fetch_all_by_Slice and fetch_by_dbID.
  The fetch by slice method will provide the same return types and require
  the same arguments as before, but will require some internal changes.

  The method fetch_all_by_RawContig will be made obsolete (it is equivalent to
  fetching by a slice of a contig) but may be left in as an alias for the
  fetch all by slice method for backwards compatibility.

  In the old system methods which return features fetched by non-locational
  means (i.e. neither by slice or contig) generally returned features in the
  same coordinate system that they were stored (native coordinate system).
  The new system will force the API user to be explicit about the coordinate
  system they wish to retrieve the feature in.  For backwards compatibility
  a 'default' coordinate system may be assumed if one is not provided.

  For example the usage of fetch_by_dbID and fetch_by_stable_id style methods
  would become the following:

  $f = $feature_adaptor->fetch_by_dbID($id, 'chromosome');
  $f = $feature_adaptor->fetch_by_stable_id($stable_id, 'clone');

  If the feature was not defined in that system undef would be returned.  If
  the feature did not exist at all, an exception would be thrown.

  The algorithm for fetching features becomes something like:

  (1) Check with coord system is requested or that slice is in.
  (2) Check which coord system features are in
  (3) Dynamically construct mapper between coord systems (or get cached one)
  (4) Cache mapper just created
  (5) Retrieve features in their native coord system using list_dnfrags style
      call on mapper object.
  (6) Remap features to the requested coord system using the mapper
  (7) Return the features


Bio::Seq
--------
  Bio::Seq objects are not useful and inconsistant with some of the API 
  methods. Some methods return a string while others return a Bio::Seq.  In 
  the instances where a Bio::Seq is returned the most common usage is to simply
  extract the sequence with a call like: $seq = $obj->seq->seq;  For 
  consistancy Bio::Seq usage will be removed in favour of simple string usage.
  *Note: This change can be done independently of the other changes.  It may be
   better to do this change seperately to avoid breaking everyones code at once
   (or maybe it would be better to do all the major code-breaking changes at
   once)



NEW FEATURES
------------


Haplotypes (and the MHC region)
-------------------------------
  There are several requirements related to haplotypes:
    - Must be able to determine which haplotypes overlap a slice
    - Must be able to run genebuild/raw computes over the haplotypes
    - Must be able to retrieve a slice on a haplotype and its flanking
      regions (i.e. the regions of the default assembly bordering the 
      haplotype).
    - It may be desireable to interpolate features from the default sequence
      onto the haplotype

   Proposal:
    Create a new table assembly_exception to describe unusual assembly 
    regions such as haplotypes and PARs.
    The haplotype will be present as a full length 'chromosome' in the dnfrag 
    table (or other appropriate coordinate system) but only the region which
    differs from the the default assembly will be described in the chromosome
    table.  The regions which are identical will be described by the 
    assembly_exception table. 

      assembly_exception
      ------------------   
      seq_region_id        int
      seq_region_start     int
      seq_region_end       int
      exc_type          enum('HP', 'PAR')
      exc_seq_region_id    int
      exc_seq_region_start int
      exc_seq_region_end   int
      ori               int  (may not be needed, may implicitly be 1)
     
    It is possible to retrieve a slice on a haplotype just as any other slice
    is retrieved from the SliceAdaptor.  For example: 
    $slice = $slice_adaptor->fetch_by_region('chromosome', '6_DR52');

    The slice will have an additional method has_exceptions('haplotype') which
    will return true or false depending on whether the slice overlaps any
    regions of assembly exception of type 'haplotype'.
    This method will have to query the dnfrag table and cache the result.
    
    Another new slice method get_all_exceptions will return a listref of the
    assembly exceptions overlapping the slice.

    A slice created on a haplotype will have coordinates relative to the
    start of the chromosome NOT relative to the start of the haplotype
    region. For all intents and purposes a haplotype slice will behave as
    a normal slice.

    The feature adaptor fetch_all_by_Slice method will have to
    be altered to check whether a slice overlaps haplotype assembly
    exceptions.  If it does the following algorithm will apply:
     (a) Split the slice into regions of exception and non-exception.
         The regions of exception should be used to create slices on the 
         default chromosome not the haplotype chromosome.
     (b) Retrieve features by recursively calling fetch_by_Slice on each of
         the slices created.
     (c) Adjust the start/end of the features retrieved fromeach of the slices 
         so that they are relative to the start of the original slice, and
         place them on the original slice.
     (d) Return all of the features retrieved

    The SequenceAdaptor will also need to take haplotype slices into account.
    A similar algorithm to above will need to apply in which sequence for 
    seperate component slices is retrieved, spliced together and returned.

    For example, the assembly table could define the composition of the 
    divergent region of chromosome 6_DR52 (C), but leave the remainder of the
    chromosomal composition undefined (A,B).  However the remainder of the 
    chromosome composition would be accounted for is by 2 rows in the 
    assembly_exception table which described the synonymous regions in terms 
    of chromosome 6:
 
      A______________         B_______________ (6)
                   C ==========                (6_DR52)





Pseudo Autosomal Regions (PARs)
-------------------------------
  There are several requirements related to PARs:
    - The same sequence and features must be present on a region of
      both chromosome X and chromosome Y
    - The region and features should be returned when retreiving features
      from either chromosome.
    - It must still be possible to retrieve one of the features via its 
      identifier
    - It must still be possible to transform features in the region from 
      chromosomal coordinates to contig coords and vice-versa.
    - The genebuild should run over the region, but only once.

  Proposal:
    Use the same assembly_exception table as described in the Haplotype section
    above. Chromosome X can be the 'default' chromosome for the PAR
    and Chromosome Y can be described by the assembly table except in the 
    PAR.  The PAR on chromosome Y can be defined by the assembly_exception
    table and refer to the corresponding sequence on chromosome X.  The same
    algorithm as used for haplotypes can then be used when retrieving sequence
    or features from slices which overlap this exception on chromosome Y.

    The following diagram illustrates how chromsome X and chromosome Y would
    be defined:

    ========================================== X
           ^                 ^ 
          _|_            ____|____ (X)
    ======   ============         ============= Y


Multiple Assemblies
-------------------

TBD


Circular Chromosomes
--------------------
  We can handle circular chromosomes (or any arbitrary circular sequence) in
  a similar way the the haplotypes.  The seq_region for the circular sequence can
  have a flag set which indicates that it is circular.  The slice would have
  an additional method is_type('circular') which would return true if the
  slice was on a circular seq_region.  The following is the algorithm for 
  retrieval of features on a circular slice:
     (a) Split the slice into 3 regions: 
         (1)     slice_start -> 0, 
         (2)               1 -> frag_length, 
         (3) frag_length + 1 -> slice_end
        
     (b) Create slices on each of the regions.
         Region (1) becomes a circular slice with: 
           start = frag_length - region_length + 1
             end = frag_length
           
         Region (2) just creates a circular slice of that region
         Region (3) becomes a circular slice with:
           start = 1 - region_length
             end = 0

         Slices that would be of length < 1 are not created or used.  
         The case in which it is not necessary to create slices (1) and (3) 
         is the degenerative case: it is not necessary to create any new 
         slices and the features for this slice can be returned right away.
     (c) Retrieve features by recursively calling fetch_by_Slice on each of
         the slices created.
     (d) Adjust the start/end of features from slice (2) by adding the
         the length of slice (1).  
     (e) Adjust the start/end of features from slice (3) by adding the
         combined lengths of slice (1) and slice (2)
     (f) Return all of the features retrieved

  A very similar algorithm would be applied with regards to sequence retrieval.


Comparative Sequence (Chimp)
----------------------------

TBD


OTHER CONSIDERATIONS
--------------------

Feature Transfer Accross Assemblies
-----------------------------------
  Future assemblies (especially human assemblies) are expected to be small
  refinements of previous assemblies.  Rather then recomputing all of the new
  genes and features on these assemblies it makes more sense to transfer most
  features across from the previous assembly, only rebuilding in areas of 
  change.  We will supply a mechanism via which features from a previous 
  assembly may be transfered to a new assembly.

