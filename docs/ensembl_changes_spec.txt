ENSEMBL - API Change Specification
==================================

INTRODUCTION
------------

This document is intended as an outline of possible changes to the current 
incarnation of the EnsEMBL database schema and Perl API. This document is 
evolving and will hopefully enable us to develop a plan for the progression 
of the EnsEMBL API. Nothing is finalized and everything is open to change.
Many of the proposed alterations may need to be phased in over time or may 
never occur at all.


REVISION HISTORY
----------------

Graham Mcvicker - July  9, 2003 - Created
Graham McVicker - July 22, 2003 - Added Haplotype Spec.

GOALS
-----
-A cleaner, more intuitive API
-A more general schema able to better capture divergent assembly types
-More flexibility with regards to assembly related data such as haplotypes,
 PARs, WGS assemblies etc.

SCHEMA MODIFICATIONS
--------------------

Proposed New/Modified Tables:
-----------------------------

  seq_region
  ----------
  seq_region_id    int
  name             varchar
  coord_system_id  int
  length           int


  coord_system
  ------------
  coord_system_id   int
  name              varchar
  version           varchar
  attrib            set ('top_level', 'default_version', 'sequence_level')          


  seq_region_annotation
  ---------------------
  seq_region_id   int
  attrib          enum(htg_phase)   (possibly varchar, more values needed)
  value           varchar


  dna
  ---
  seq_region_id  int
  sequence       varchar


  assembly
  --------
  asm_seq_region_id  int
  asm_start          int
  asm_end            int
  cmp_seq_region_id  int
  cmp_start          int
  cmp_end            int
  ori                tinyint (or enum?)

  gene
  ----
  For faster retrieval and retrieval independently of transcripts and 
  exons genes will also have a seq_region_id, seq_region_start and 
  seq_region_end.
  
  gene_id             int
  type                varchar
  analysis_id         int
  seq_region_id       int
  seq_region_start    int
  seq_region_end      int
  seq_region_strand   int (or enum?)
  transcript_count   - (is this necessary? - probably can go)
  display_xref_id


  transcript
  ----------
  For faster retrieval and retrieval independently of genes and exons
  transcripts will also have a seq_region_id, seq_region_start and 
  seq_region_end. The translation_id will be removed, translations will point 
  to transcripts instead (and pseudogenes will have no translation).  
  Prediction transcripts  will now be stored as normal transcripts without 
  genes.  In order to distinguish between transcript types an analysis id will
  be necessary. Transcripts which do not have an associated gene will have a 
  NULL value for the gene_id.  An alternative solution would be to construct 
  a gene_transcript table in a similar style as the existing exon_transcript 
  table.

  transcript_id      int
  gene_id            int (NULLABLE)
  exon_count         int   - (is this necessary?)
  seq_region_id      int
  seq_region_start   int
  seq_region_end     int
  seq_region_strand  int (or enum?)
  display_xref_id    int
  analysis_id        int

  
  translation
  -----------
  Translations now reference transcripts rather than transcripts referencing
  a single (or no) translation.  This allows for more elegant handling of 
  pseudogenes (where there is no translation) and also can be used to supply
  multiple translations for a single transcript (e.g. polycistronic genes).

  translation_id   int
  transcript_id    int
  start_exon_id    int
  end_exon_id      int
  seq_start        int
  seq_end          int



  all feature tables
  ------------------
  All feature tables would now have seq_region_id, seq_region_start, 
  seq_region_end, seq_region_strand instead of contig_id, contig_start,
  contig_end.  This includes the repeat_feature, simple_feature, 
  dna_align_feature, protein_align_feature, exon, marker_feature,
  and qtl_feature tables.

  
Removed Tables
--------------

  prediction_transcript
  ---------------------
  PTs are now stored as ordinary transcripts without genes.  They should 
  probably be computed in chromosomal coordinates instead of contig 
  coordinates.
  
  contig
  ------
  Contigs are no longer needed.  They are stored as entries in the seq_region
  table with type 'contig'.  The embl_offset and clone_id will not be
  necessary as their relationship to clones can be described by the 
  assembly table.

  clone
  -----
  Clones are no longer needed.  Clones are stored as entries in the seq_region 
  table with type 'clone'.  The modified timestamp will be discarded as it is 
  no longer maintained anyway.  The embl_acc, version, and embl_version 
  columns are redundant and will also be discarded.  Versions
  can simply be appended onto the end of the name with a '.'.  Any additional
  information that needs to be present (such as htg_phase) can be added to
  the seq_region_annotation table.

  chromosome
  ----------
  This table is no longer needed.  Chromosomes can be stored in the 
  seq_region table with type 'chromosome'.





META INFORMATION
----------------

Considerable more meta information will have to be stored in the core
databases in order for the general approach to be maintained.  
This information will be stored in the new coord_system table and in the 
meta table.

Meta information includes the following:

  * The seq_region coordinate system of every type of feature stored in the
    database.  Initially we will only allow for a single coordinate system
    per table (e.g. all genes will have to be stored in the same coordinate 
    system).  Eventually we may extend this to be allowed to store differing
    coordinate systems in a single table. This information will be present in 
    the meta table.

  * The top-level seq_region type (coordinate system). For human
    this would be 'chromosome'.  For briggsae this may be something like
    'scaffold' or 'super contig'.  This information would be used to construct
    the web display and would possibly be the default coordinate system when 
    a coordinate system is unspecified by a user. This is stored as a flag
    in the coordinate system table.

  * The default version of each coordinate system.  This is stored as a flag
    in the coordinate system table.

  * The coordinate system where sequence is stored.  This will be stored as a
    flag in the coordinate system table.  Initially it will only be possible
    to have a single coordinate system in which sequence is stored.  This 
    may be extended in the future to allow sequence to be stored for multiple
    coordinate systems.

  * The assembly relationships between coordinate systems.  For example  
    the clone, chromosome and nt_contig coordinate systems may all be 
    constructed from the contig coordinate system:
      contig -> clone
      contig -> chromosome
      contig -> nt_contig
    Or there may be a more hierarchical approach:
      contig    -> clone
      clone     -> nt_contig
      nt_contig -> chromosome
    This information will be stored in the meta table.

   * The names of the allowable coordinate systems.  This would allow for 
     quick validation of API requests and provide a list that could be used
     by the website for coordinate system selection.  This information will be
     stored in the coordinate system table.


API CHANGES
-----------

Slice
-----
  Slice methods chr_start, chr_end, chr_name will be renamed start, end, 
  seq_region_name.  For backwards compatibility it should be possible to 
  keep the old methods and chain them to the new methods.

  A new slice method 'coord_system' will be added and will denote the type
  of seq_region the slice is built on.

  Slices will represent a region on a seq_region as opposed to a region on a
  chromosome.  Slices will be immutable (i.e. their attributes will not be
  changeable).  A new slice will have to be created if the attributes are to
  be changed.

  The following attributes will therefore define a unique slice:
  coord_system    (e.g. 'chromosome' or 'clone')
  version         (e.g. 'NCBI33' or '')
  seq_region_name (e.g. 'X' or 'AL035554.1')
  start           (e.g. 1000000 or 1)
  end             (e.g. 2000001 or 800)
  strand          (e.g. 1 or -1)

  The name method will return the above values joined by a ':' delimiter, and
  will not be settable:
  e.g.  'chromosome:NCBI33:X:1000000:2000001:1' or 'clone::AL035554.1:1:800:-1'
  This value can be used as a hashvalue that uniquely defines a slice.

  The concept of an 'empty' slice will no longer exist.

  The get_tiling_path method will have to be implemented differently for the
  new system.  It will take a coord_system string as an argument and rather 
  than returning a list of Tile objects it will return a listref of triplets 
  containing a start int, and end int, and a 'to' slice object.  The following 
  is an example of how this method would be used ($clone is a reference to a 
  slice object in the clone coordinate system):

    my $clone_path = $slice->get_tiling_path('clone');

    foreach my $tile (@$clone_path) {
      my ($start, $end, $clone) = @$tile;
      print $slice->seq_region_name, ':', $start, '-', $end , ' -> ',
            $clone->seq_region_name, ':', $clone->start, '-', $clone->end, 
            $clone->strand, "\n";
    }

    An optional second argument to the get_tiling_path will be the version.


Tile
----
  The tile object will no longer be necessary.


SliceAdaptor
------------
  The Slice adaptor must provide a method to fetch a slice via its coordinate
  system, seq_region_name, start, end, and strand.  
  The old, commonly used method fetch_by_chr_start_end can be altered to 
  simply chain to this new method as can most other SliceAdaptor methods.

  Another method which will be necessary with the disapearence of the Clone,
  RawContig and Chromosome adaptors is the one which allows for all slices
  of a certain type to be retrieved.  For example it is often necessary to 
  retrieve all chromosomes, or clones for a species.  This method could be
  named fetch_all_by_coord_system or something similar.  The old fetch_all
  methods on the ChromosomeAdaptor, RawContigAdaptor, CloneAdaptor, etc. can
  chain to the new method for backwards compatibility.

  Proposed Method Names and Signatures
  ------------------------------------
    Slice fetch_by_region(coord_system, name)
    Slice fetch_by_region(coord_system, name, start)
    Slice fetch_by_region(coord_system, name, start, end)
    Slice fetch_by_region(coord_system, name, start, end, strand)
    Slice fetch_by_region(coord_system, name, start, end, strand, version)
    listref of Slices fetch_all(coord_system)
    listref of Slices fetch_all(coord_system, version)
  
RawContig
---------
  The RawContig object is no longer necessary with the new system.  RawContigs
  are replaced by Slices with coord_system = 'contig'. In the interests of 
  backwards compatibility the RawContig class can stick around for a while,
  as a minimal implmentation inheriting from the Slice class.


RawContigAdaptor
----------------
  The RawContigAdaptor is no longer necessary.  The RawContigAdaptor is 
  replaced by the SliceAdaptor.  For backwards compatibility a minimal 
  implementation of the RawContigAdaptor can remain which inherits from the 
  SliceAdaptor.

Clone
-----
  The Clone object is no longer necessary in the new system.  Clones are 
  replaced by Slices with coord_system = 'clone'. For backwards compatibility
  a minimal implementation can remain which inherits from the Slice object.

CloneAdaptor
------------
  The CloneAdaptor object is no longer necessary in the new system.  The
  CloneAdaptor is replaced by the SliceAdaptor.  For backwards compatibility
  a minimal implementation can remain which inherits from the SliceAdaptor.

Chromosome
----------
  The Chromosome object is no longer necessary in the new system.  The
  Chromosome is replaced by Slices with coord_system = 'chromosome' (or
  whatever the top level seq_region type is for that species).  For backwards
  compatibility a minimal implementation can remain which inherits from the
  Slice object.  Statistical information (e.g. known genes, genes, snps) that 
  was on chromosomes should be possible to calculate directly from the 
  map_density table with very little impact on performance.

ChromosomeAdaptor
-----------------
  The Chromosome object is no longer necessary in the new system. The 
  ChromosomeAdaptor is replaced by the SliceAdaptor.  For backwards 
  compatibility a minimal implementation which inherits from the SliceAdaptor
  can remain.


Root
----
  Every class in the current EnsEMBL perl API inherits directly or indirectly
  from Bio::EnsEMBL::Root.  This inheritance is almost exclusively for the
  following following three methods:
    throw
    warn
    _rearrange

  Nothing is gained by implementing this relationship as inheritance, and there
  are several disadvantages:
    (1) Everything must inherit from this class to use those 3 object methods.
    This can result in patterns of multiple inheritance which are generally
    considered to be a bad thing.

    (2) It is not possible to use the throw, warn or rearrange method within
    the constructor until the object is blessed.  Blessing the object first
    and then calling rearrange to extract named arguments is slower because
    the blessed hash needs to be expanded as more keys are added and several
    key access/value assignements may need to be performed.

    (3) Objects become larger and object construction becomes slightly slower
    because constructors traverse an additional level of inheritance.

  A better approach would be to make the methods static and create a static
  utility class that exported the methods.  Note, however, that warn is builtin
  perl function and it may be better if we renamed this method.
  They could then be used as follows:

  #
  # OLD STYLE
  #
  package Old;

  use Bio::EnsEMBL::Root;

  @ISA = qw(Bio::EnsEMBL::Root);

  sub new {
    my $caller = shift;
    my $class = ref($caller) || $caller;

    $self = $class->SUPER::new(@_);
    
    my ($start, $end) = $self->_rearrange(['START', 'END'], @_);

    if(!defined($start) || !$defined($end)) {
      $self->throw('-START and -END arguments are required');
    }

    $self->{'start'} = $start;
    $self->{'end'}   = $end;

    return $self;
  }

  #
  # NEW STYLE
  #
  package New;

  use Bio::EnsEMBL::Util::Exception qw(throw warning);
  use Bio::EnsEMBL::Util::Argument  qw(rearrange);

  sub new {
    my $caller = shift;

    my $class = ref($caller) || $caller;

    my ($start, $end) = rearrange(['START', 'END'], @_);

    if(!defined($start) || !defined($end)) {
      throw('-START and -END arguments are required');
    }

    return bless {'start' => $start, 'end' => $end}, $class;
  }



Storable Base Class
-------------------
  Almost all business objects in the EnsEMBL system are storable in the db
  and the ones which are always require 2 methods: dbID and adaptor.  It would
  make sense in order to reduce code duplication to have all storable objects
  inherit from a Storable base class which implemented these.

Features
--------
  All features should inherit from a base class that implements common feature
  functionality.  Presently this role is filled by the bloated SeqFeature class
  which inherits from Bio::SeqFeature and Bio::SeqFeatureI etc.
  This class can be ditched in favour of a smaller, less complicated 
  implementation named Feature.  To make classes more polymorphic in general,
  the gene, and transcript objects should now also inherit from the Feature
  class.  This class should implement the following
  core methods common to all features:

    start
    end
    strand
    slice (formerly named contig/entire_seq/etc.)
    transform
    transfer
    map
    
  The feature class would likely inherit from the Storable base class and
  thereby inherit the following methods:

    adaptor
    dbID

  The signature and behaviour of the transform method will be changed.  The
  existing method works differently depending on the arguments passed as 
  described below: 

    OLD transform(no arguments)
    -----------------------
      Transforms from slice coordinates to contig coordinates.  The feature
      is changed in place and returned.  If the feature already is in contig
      coordinates an exception is thrown.  The feature may be split into two
      features in which case both features are returned (not sure if one of
      them is transformed in place).  Some features are not permitted to be
      split in two in which case an exception is thrown? (not sure) if it is
      to be split accross contigs.

    OLD transform(slice)
    ----------------
      If the feature is already in slice coordinates and the slice is on the
      same chromosome the features coordinates are simply shifted.  If the
      feature is already in slice coordinates but on a different chromosome
      an exception is thrown.
      It the feature is in contig coordinates and the slice is not empty then
      it is transformed onto the new slice (or an exception is thrown if the 
      transform would cause the feature to end up on a different chromosome
      than the slice).  If the feature is in contig coordinates and the
      slice is an empty slice the feature is transformed into chromosomal
      coordinates and placed on a newly created slice of the entire chromosome.

    The new transformation will have only a single valid signature and will
    split it's responsibilities with the new transfer method.  The transfer 
    method will transfer a feature onto another slice, whereas the transform
    method will simply convert coordinate systems.  As well transform will 
    NOT transform features in place but will rather return the newly 
    transformed feature as a new object:
    
    transform(coord_system)
    -----------------------
      Takes a single string specifying the new coord system. If the coord
      system is not valid an exception is thrown. If the coord system is the
      same coord system as the feature is currently in a new feature that is
      a copy of the old one will still be returned.  This will also retrieve
      a slice which is the entire span of the region of the coordinate system
      that this feature is being transformed to.  For example transforming
      an exon in raw contig coordinates to one in chromosomal coodinates
      will place the exon on a slice of an entire chromosome.  If a feature
      spans a boundary in the coordinate system, undef is returned by the
      method instead.

    transfer(slice)
    ----------------
      Shifts a feature from one slice to another.  If the new slice is in the
      same coordinate system but different seq_region_name (e.g. both 
      chromosomal but different chromosomes) an exception is thrown.  
      If the new slice is in a different coordinate system then the 
      transform method is called first.  If the feature would be split 
      accross a boundary undef is returned instead.  After the transform 
      there follows a potential move, if the slice does not cover the full 
      seq_region. If there is no transform call necessary, the feature is 
      copied and then moved.


    move( start, end, strand )
    --------------------------
      In place change of the coordinates of the feature. It will stay on the 
      same slice.

    map(coord_system)
    -----------------
      Performs the mapping of a feature from one coordinate system to another
      but rather than returning a feature a list of coordinate/gap objects is
      returned. This enables people to construct their own mappings even if
      the feature is split accross boundaries in a lower level coordinate
      system.
 

StickyExon
----------
  The sticky exon object will not be present in the new system.  It does not
  make sense to define features in a coordinate system where they are simply 
  not present.  Exons are calculated in chromosomal coordinates and they
  will generally be retrieved in the same coordinates system.  It will
  of course be possible to still retrieve exons in contig coordinates but only
  is they are fully defined on the contigs of interest.
  The split coordinates can be obtained through a call to the base feature 
  method map().


AssemblyMapper
--------------
  The assembly mapper object will have to become more clever.  It must be
  able to load a mapper with using 'coordinate system chaining'.  Currently
  the mapper is loaded with coordinates read directly from the assembly table
  but this will not always be possible.  For example to map from the NT contig
  coordinate system to the clone coordinate system the mapper will have to 
  do the following:
  NTContig -> Contig -> Clone

  In the above example the assembly mapper would have do the following:

  (1) Create a mapper object between the NTContig and Contig region
  (2) Create a mapper object between the Contig and Clone region
  (3) Create and return a third mapper constructed from the sets of mappings
  generated by the intermediate mappers.

  As an intermediate implementation step it would be possible to leave the
  AssemblyMapper almost as is and to require explicit mappings between all 
  coordinate systems of intereset to be present in the assembly table.  The
  AssemblyMapper would only support 1 step mappings and the more complex
  2 step mappings could be introduced at a later date.

  


FeatureAdaptors
---------------
  Most FeatureAdaptors should inherit from the BaseFeature adaptor.  As a 
  minimum feature adaptors should have fetch_all_by_Slice and fetch_by_dbID.
  The fetch by slice method will provide the same return types and require
  the same arguments as before, but will require some internal changes.

  The method fetch_all_by_RawContig will be made obsolete (it is equivalent to
  fetching by a slice of a contig) but may be left in as an alias for the
  fetch all by slice method for backwards compatibility.

  In the old system methods which return features fetched by non-locational
  means (i.e. neither by slice or contig) generally returned features in the
  same coordinate system that they were stored (native coordinate system).
  The new system will force the API user to be explicit about the coordinate
  system they wish to retrieve the feature in.  For backwards compatibility
  a 'default' coordinate system may be assumed if one is not provided.

  For example the usage of fetch_by_dbID and fetch_by_stable_id style methods
  would become the following:

  $f = $feature_adaptor->fetch_by_dbID($id, 'chromosome');
  $f = $feature_adaptor->fetch_by_stable_id($stable_id, 'clone');

  If the feature was not defined in that system undef would be returned.  If
  the feature did not exist at all, an exception would be thrown.

  The algorithm for fetching features becomes something like:

  (1) Check with coord system is requested or that slice is in.
  (2) Check which coord system features are in
  (3) Dynamically construct mapper between coord systems (or get cached one)
  (4) Cache mapper just created
  (5) Retrieve features in their native coord system using list_seq_regionss 
      style call on mapper object.
  (6) Remap features to the requested coord system using the mapper
  (7) Return the features


CoordSystemAdaptor
------------------
  A CoordSystemAdaptor will provide access to the information in the 
  coord_system table.  This adaptor will not provide coord_system objects
  but will provide useful methods to obtain meta information stored in
  this table.


NEW FEATURES
------------

Assembly Exceptions (Symbolic Sequence Links)
---------------------------------------------

  It is sometimes desirable to have multiple regions refer to the same 
  sequence.

  In much the same way a symlinked file acts as a pointer to a real file, 
  a symlinked region can point to another region of sequence.

  This can be described in the database through the addition of a table which 
  has a structure that mirrors that of the assembly table. The assembly table
  does not define the structure underlying this seq_region, and it does not
  have sequence of its own.  By means of the assembly_exception table this 
  seq_region points to another seq_region where the underlying sequence is 
  defined:

      assembly_exception
      ------------------   
      seq_region_id        int
      seq_region_start     int
      seq_region_end       int
      exc_type             enum('HAP', 'PAR')
      exc_seq_region_id    int
      exc_seq_region_start int
      exc_seq_region_end   int
      ori                  int  (may not be needed, may implicitly be 1)

   When fetching features and sequence from a slice that overlaps a symlinked
   region, the features and sequence from the symlinked region are returned.  
   This may be implemented by altering fetch by slice calls and adding a 
   SliceAdaptor method with splits a slice into non-symlinked components.  
   The following algorithm would apply to sequence and feature fetches:
      (1) Split the slice into non-symlinked component slices
      (2) Recursively call the method with the component slices
      (3) Adjust the start and end of the returned features and place them
          back on the original slice (or splice the sequence together if this
          is a sequence fetch)
      (4) Return the features or sequence
   
   Consider a slice which overlaps regions (A), (B), and (C) on chromosome Y:

             ===============  (chrX)
               ^^^^^^^^^^^
     ========   symlink     =========  (chrY)
      (A)          (B)         (C)

   Regions (A) and (C) are described by the assembly table, but region (B)
   is described in the assembly_exception table and points to a region of
   chromosome Y.  When features or sequence are retrieved the slice is split
   into 3 component slices which have no symlinks:  region (A) and (C) are
   slices on chromosome Y but region (B) is made into a slice on chromsome (X).
   All of the features are fetched from the individual slices adjusted by
   some addition and placed on back on the original Slice before being
   returned. 
  
   
    
Haplotypes (and the MHC region)
-------------------------------
  There are several requirements related to haplotypes:
    - Must be able to determine which haplotypes overlap a slice
    - Must be able to run genebuild/raw computes over the haplotypes
    - Must be able to retrieve a slice on a haplotype and its flanking
      regions (i.e. the regions of the default assembly bordering the 
      haplotype).
    - It may be desireable to interpolate features from the default sequence
      onto the haplotype

   Proposal:
    The haplotype will be present as a full length 'chromosome' in the 
    seq_region table (or other appropriate coordinate system) but only the 
    region which differs from the the default assembly will be described in 
    the chromosome table.  The regions which are identical will be described 
    by the assembly_exception table. 
  
    It is possible to retrieve a slice on a haplotype just as any other slice
    is retrieved from the SliceAdaptor.  For example: 
    $slice = $slice_adaptor->fetch_by_region('chromosome', '6_DR52');
    
    A slice created on a haplotype will have coordinates relative to the
    start of the chromosome NOT relative to the start of the haplotype
    region. For all intents and purposes a haplotype slice will behave as
    a normal slice.

    For example, the assembly table could define the composition of the 
    divergent region of chromosome 6_DR52 (C), but leave the remainder of the
    chromosomal composition undefined.  The remainder of the 
    chromosome composition would be accounted for by 2 rows in the 
    assembly_exception table which described the synonymous regions in terms 
    of chromosome 6:
 
       ==============  6       ==============  6
            ^                         ^
       _____|________          _______|______  
                   C ==========               6_DR52





Pseudo Autosomal Regions (PARs)
-------------------------------
  There are several requirements related to PARs:
    - The same sequence and features must be present on a region of
      both chromosome X and chromosome Y
    - The region and features should be returned when retreiving features
      from either chromosome.
    - It must still be possible to retrieve one of the features via its 
      identifier
    - It must still be possible to transform features in the region from 
      chromosomal coordinates to contig coords and vice-versa.
    - The genebuild should run over the region, but only once.

  Proposal:
    Use the assembly_exception table in a similar fashion as it is used
    for the haplotypes described above. Chromosome X can be the 'default' 
    chromosome for the PAR and Chromosome Y can be described by the assembly 
    table except in the PAR.  The PAR on chromosome Y can be defined by the 
    assembly_exception table and refer to the corresponding sequence on 
    chromosome X.  The same algorithm as used for haplotypes can then be used 
    when retrieving sequence or features from slices which overlap this 
    exception on chromosome Y.

    The following diagram illustrates how chromsome X and chromosome Y could
    be defined:

    ========================================== X
           ^                 ^ 
          _|_            ____|____ 
    ======   ============         ============= Y


Multiple Assemblies
-------------------

TBD

Circular Chromosomes
--------------------

TBD


Comparative Sequence (Chimp)
----------------------------

TBD


OTHER CONSIDERATIONS
--------------------

Feature Transfer Accross Assemblies
-----------------------------------
  Future assemblies (especially human assemblies) are expected to be small
  refinements of previous assemblies.  Rather then recomputing all of the new
  genes and features on these assemblies it makes more sense to transfer most
  features across from the previous assembly, only rebuilding in areas of 
  change.  We will supply a mechanism via which features from a previous 
  assembly may be transfered to a new assembly.

