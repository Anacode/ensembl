\documentclass[11pt,a4paper]{article}

\usepackage{
  fancyheadings,lscape,
  rotating,float,longtable,epsfig
}

\newcommand{\sdp}{\setlength{\baselineskip}{16truept}} %double spacing

\begin{document}

\title{Ensembl. Open Genome Annotation}
\author{Ewan Birney, Michele Clamp, Tim Hubbard and others\\www.ensembl.org}


\maketitle
 
\newpage

\section{In 10 lines or less...}

Ensembl is a software system which supports automatic annotation of
genome projects, optimised for large, eukaryotic genomes. The best
example of this is the annotation of the human genome, which Ensembl
is one the leading groups. In particular Ensembl can annotate rapidly
updating fragmentary genomes with large introns. For most other systems
this is a challenge.

Ensembl is an entirely open software project: you can use its data
without restriction and the code with very few restrictions. This
document is aimed at getting bioinformatics developers over the
learning curve in understanding Ensembl.

\section{Before you start}

This document is going to assumme you understand the basics of
bioinformatics; if the words ``BLAST'', ``STS Marker'' or ``reverse
strand'' confuse you then the rest of this document probably will be
indecipherable. As well as being a reasonably complex (but only where
it has to be), Ensembl is a large software project. The code for
example is split up across 9 and counting cvs modules and has been
developed over 2 years (in the case of bioperl, more like 6 years)
with currently 18 active developers on the project. There are more
than 100 different objects in Ensembl that get combined in different
ways.  This is not a project you will get to know within one or two
days of playing around. That said, the next section - first steps with
Ensembl - will get you over the first speed bump. However before we
jump into the first steps, a quick answer of some often asked
questions:

\begin{description}
\item[Why Perl? Why not Python or Java?] We have a love-hate relationship
with Perl, but the basic answer is threefold: (a) we knew it would work
as we had experience in writing systems that scaled to this level in Perl
(b) We had Bioperl as a basic starting point (Biojava was not mature when we
started and is still someway from what we need) (c) we knew we could hire people
with Perl and molecular biology knowledge. More about this later (section \ref{future})
\item[Why MySQL? Why not Oracle? or AceDB?] We have been very happy with MySQL.
For us it was an easy RDB to learn (light on the DBA aspects) and has scaled well
to very large loads and tables. We have not found the lack of transactions or views
showstoppers for our work. With AceDB we did not have confidence in to scale to the
sort of problems we expected to have.
\item[Does it really have to be this complex?] Mainly yes. There are a number of places
where we don't help ourselves because the code is old and in light of a better
understanding, sometimes somewhat off the mark. This is what you expect in large
projects
\item[Are you sure? I have run BLAST and Genscan myself...] Honestly, if we can make it
simpler, we will! Running BLAST and Genscan yourself and doing small
stuff is pretty easy. Alot of what Ensembl does at the basic end is
this easy, but there are one or two areas where things get much more complex and
the scale of the problem makes even doing simple things hard.
\end{description}

Enough waffle! Let's get to the code

\section{Installing Ensembl}

Before you can code with Ensembl you need to download and install the
following packages (the order listed is the best order to download them in).

\begin{description}
\item[MySQL] Fetch from www.mysql.com. Unpack and do the standard ``./configure'',
``make'' (become root) ``make install''. Use --prefix on the configure script
to install somewhere other than the ``standard'' places. Start the mysql daemon by
going ``mysql\_install\_db'' (you only do this once to initalise the mysql installation) followed
by ``safe\_mysqld'' to start the mysql daemon. Read more in the Mysql docs to get an
understand of what this means.
\item[DBI] DBI is the perl bindings to relational databases. The easiest way to install
this is using the in-build installation system in Perl, called
CPAN. Become root, go ``perl -MCPAN -e shell'', at the cpan prompt go ``install DBI''.
Alternative download the DBI package from CPAN and install by going ``perl Makefile.PL'',
``make'', (become root), ``make install''.
\item[MySQL DBI drivers] DBI only provides the framework to use a relational database:
you need the MySQL drivers. Again, using CPAN (``perl -MCPAN -e shell'') go ``install DBD::Mysql''.
\item[Bioperl] Ensembl sits ontop of Bioperl as a basic bioinformatics library (many of the
Ensembl developers also contribute to Bioperl). Unlike the previous
packages in which ``the latest version'' is likely to work, there is
more of a coupling between Ensembl and bioperl. Currently Ensembl
0.8.0 has a dependency on Bioperl 0.6.2 (in fact the head of the 0.6
stable branch for bioperl - but you would have to be using Ensembl in
mind numbing detail to notice the difference).  At the moment, most
but certainly not all, of Ensembl will work with the forthcoming 0.7
series of bioperl, and it will throw alot of warnings. To download, again you can
use cpan with ``install bioperl-0.6.2.tar.gz''. If you are reading this document past Ensembl0.8
you'll have to root around on our web pages to see which bioperl to use with the Ensembl you aim
to download.
\end{description}

Apologies for the number of external packages to install. This is I'm afraid to say 
par for the course for this sort of project.

You are now ready to download Ensembl. You have two basic options of what to download.
(a) Download a tar file of the code which is synchronised with an Ensembl data release.
You will find this in ftp://ftp.ensembl.org/pub/current/software/ (b) Download the leading edge
version using anonymous cvs. The cvs repository is cvs.sanger.ac.uk, username cvs, password
CVSUSER (case important). You want to check out the ensembl module 

If anonymous cvs makes no sense to you, go for the tar ball.

Poke your nose into the ensembl directory. You should have a number of directories there, being
modules, scripts, docs and other stuff. You want to cd into modules. This is a top level 
perl modules directory. Go ``perl Makefile.PL'' followed by ``make test''. This will run the
Ensembl test system.

The Ensembl test systems fails for 3 main reasons.

\begin{description}
\item[No Bioperl] Phenotype: Could not find Bio::Root::RootI in @ISA. You have not installed Bioperl
(see above!). Alternatively make sure Bioperl is in your PERL5LIB.
\item[No DBI/MySQL DBD] Phenotype: Could not find DBI in @ISA. You have not installed DBI or the
MySQL DBD drivers. See above 

\item[No permissions on local MySQL]
Phenotype DBI connect failed: Unknown MySQL Server Host localhost not
found.  

\end{description} 

The first two is just your error. The third is more understandable. Ensembl needs to connect to 
a local mysql to run tests (it loads and dumps mini mysql databases for testing purposes). By
default it connects to localhost mysql as user root with no password. This is a bad - but default -
connection protocol!

To change this copy the file in modules/t called
EnsTestDB.conf.example to EnsTestDB.conf (also in modules/t), and edit
the configuration to match your system: in particular you want to
connect to a database as a user that has drop and create database
priviledges. The EnsTestDB.pm module will create a unique database
name for each test, so you need not worry about it ``trashing'' other
pieces of information.

When the test system runs, it will output alot of stuff to the terminal, but hopefully say
``All Tests Successful'' at the end. It is really worth getting the test system to run, as then you
will be confident that Ensembl actually works on your system as you embark on more complex processes.

\section{First script}

The first script we'll write is to dump the underlying DNA fragments which make an assembly out
as fasta format. What we'll use as a database is one of the mini-tests databases used by the testing
system. The good thing about this is that (a) they are small (b) they are present in the source
distribution - no need to worry about downloading additional information and (c) they are guarenteed
to be working with the source code you have.

First we need to build the database, which we will call test\_ensembl

\begin{description}
\item[create a test database]. Either go ``mysqladmin -u user\_who\_can\_create create test\_ensembl'' or open
a mysql terminal window with ``mysql -u user\_who\_can\_create'' and go ``create database test\_ensembl''
in the terminal window
\item[load the schema]. The schema is kept in sql/table.sql. View the file if you are interested:
these SQL ``create table'' syntax is called the DDL of the database, or the schema, and provides the 
definition of the structure of the database. Go ``mysql -u user\_who\_can\_write test\_ensembl < sql/table.sql''
\item[load the database]. We'll use the staticgoldenpath.dump mini-database found in modules/t directory.
Again view the file if you are interested. The ``insert'' statements here put data into the database. Go
``mysql -u user\_who\_can\_write test\_ensembl < modules/t/staticgoldenpath.dump''
\end{description}

We are now ready for our first script (finally!)

\begin{verbatim}

#!/usr/local/bin/perl

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;


# this will die if if can't load this database
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::Obj/host=localhost;user=read_only_user;dbname=test_ensembl');

# build seqio output stream

$seqout = Bio::SeqIO->new( '-format' => fasta, '-fh' => \*STDOUT);

# get out all the accession numbers (clone ids) for
# sequences in this database

@clones = $db->get_all_Clone_id();


# for each clone_id, get the clone
foreach $clone_id ( @clones ) {
	$clone = $db->get_Clone($clone_id);
	foreach $fragment ( $clone->get_all_Contigs() ) {
		$seqout->write_seq($fragment);
   	}
}

\end{verbatim}

To explain this in more detail:

\begin{verbatim}

#!/usr/local/bin/perl

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;

\end{verbatim}

This loads up the necessary Perl modules. Only one Perl module for Ensembl is needed: DBLoader.
DBLoader will at run time load up the modules required for loading the database of choice

\begin{verbatim}
# this will die if if can't load this database
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::Obj/host=localhost;user=read_only_user;dbname=test_ensembl');
\end{verbatim}

This connects to the actual database. The string used for DBLoader is a sort of combined software+location
string. The first part indicates that the Bio::EnsEMBL::DBSQL::Obj is the software module which will
negotiate the Ensembl objects from the database. The remainder are parameters used in that modules
construction, in this case the host, user and dbname of the database

\begin{verbatim}
$seqout = Bio::SeqIO->new( '-format' => fasta, '-fh' => \*STDOUT);
\end{verbatim}

This builds a standard Bioperl output stream. In this case to Fasta format to stdout.

\begin{verbatim}
@clones = $db->get_all_Clone_id();


# for each clone_id, get the clone
foreach $clone_id ( @clones ) {
	$clone = $db->get_Clone($clone_id);
	foreach $fragment ( $clone->get_all_Contigs() ) {
		$seqout->write_seq($fragment);
   	}
}
\end{verbatim}

This is the real guts of the system. For each id, it is making a Clone object with the call
``\$db->get\_Clone''. In Ensembl a Clone is really a single sequence entry from EMBL/GenBank. For
draft (unfinished) cases, these are split up into a series of pieces of contiguous DNA, called ``RawContigs''
in Ensembl terminology. Each ``RawContig'' implements the Bio::SeqI interface of bioperl, meaning that standard
bioperl methods (including dump to flat files) work fine. 


It is a pretty simple case to do a pretty simple task. 

\section{Ensembl Cookbook}

To be continued.

\end{document}







