\documentclass[11pt,a4paper]{article}

\usepackage{
  fancyheadings,lscape,
  rotating,float,longtable,epsfig
}

\newcommand{\sdp}{\setlength{\baselineskip}{16truept}} %double spacing

\begin{document}

\title{Ensembl. Open Genome Annotation}
\author{ensembl-dev@ebi.ac.uk\\www.ensembl.org}


\maketitle

\newpage
\tableofcontents
\newpage

 
\newpage

\section{In 10 lines or less...}

Ensembl is a software system which supports automatic annotation of
genome projects, optimised for large, eukaryotic genomes. The best
example of this is the annotation of the human genome, which Ensembl
is one the leading groups. In particular Ensembl can annotate rapidly
updating fragmentary genomes with large introns. For most other systems
this is a challenge.

Ensembl is an entirely open software project: you can use its data
without restriction and the code with very few restrictions. This
document is aimed at getting bioinformatics developers over the
learning curve in understanding Ensembl.

\section{Before you start}

This document is going to assumme you understand the basics of
bioinformatics; if the words ``BLAST'', ``STS Marker'' or ``reverse
strand'' confuse you then the rest of this document probably will be
indecipherable. As well as being a reasonably complex (but only where
it has to be), Ensembl is a large software project. The code for
example is split up across 9 and counting cvs modules and has been
developed over 2 years (in the case of bioperl, more like 6 years)
with currently 18 active developers on the project. There are more
than 100 different objects in Ensembl that get combined in different
ways.  This is not a project you will get to know within one or two
days of playing around. That said, the next section - first steps with
Ensembl - will get you over the first speed bump. However before we
jump into the first steps, a quick answer of some often asked
questions:

\begin{description}

\item[Why Perl? Why not Python or Java?] We have a love-hate
relationship with Perl, but the basic answer is threefold: (a) we knew
it would work as we had experience in writing systems that scaled to
this level in Perl (b) We had Bioperl as a basic starting point
(Biojava was not mature when we started and is still someway from what
we need) (c) we knew we could hire people with Perl and molecular
biology knowledge.

\item[Why MySQL? Why not Oracle? or AceDB?] We have been very happy
with MySQL.  For us it was an easy RDB to learn (light on the DBA
aspects) and has scaled well to very large loads and tables. We have
not found the lack of transactions or views showstoppers for our work
- so far. With AceDB we did not have confidence that it would scale to
the sort of problems we expected to have.

\item[Does it really have to be this complex?] Mainly yes. There are a
number of places where we don't help ourselves because the code is old
and in light of a better understanding, sometimes somewhat off the
mark. This is what you expect in large projects

\item[Are you sure? I have run BLAST and Genscan myself...] Honestly,
if we can make it simpler, we will! Running BLAST and Genscan yourself
and doing small stuff is pretty easy. Alot of what Ensembl does at the
basic end is this easy, but there are one or two areas where things
get much more complex and the scale of the problem makes even doing
simple things hard.

\end{description}

Enough waffle! Let's get to the code

\section{Installing Ensembl}

Before you can code with Ensembl you need to download and install the
following packages (the order listed is the best order to download them in).

\begin{description}
\item[MySQL] Fetch from www.mysql.com. Unpack and do the standard ``./configure'',
``make'' (become root) ``make install''. Use --prefix on the configure script
to install somewhere other than the ``standard'' places. Start the mysql daemon by
going ``mysql\_install\_db'' (you only do this once to initalise the mysql installation) followed
by ``safe\_mysqld'' to start the mysql daemon. Read more in the Mysql docs to get an
understand of what this means.
\item[DBI] DBI is the perl bindings to relational databases. The easiest way to install
this is using the in-build installation system in Perl, called
CPAN. Become root, go ``perl -MCPAN -e shell'', at the cpan prompt go ``install DBI''.
Alternative download the DBI package from CPAN and install by going ``perl Makefile.PL'',
``make'', (become root), ``make install''.
\item[MySQL DBI drivers] DBI only provides the framework to use a relational database:
you need the MySQL drivers. Again, using CPAN (``perl -MCPAN -e shell'') go ``install DBD::Mysql''.
\item[Bioperl] Ensembl sits ontop of Bioperl as a basic bioinformatics library (many of the
Ensembl developers also contribute to Bioperl). Unlike the previous
packages in which ``the latest version'' is likely to work, there is
more of a coupling between Ensembl and bioperl. Currently Ensembl
0.8.0 has a dependency on Bioperl 0.6.2 (in fact the head of the 0.6
stable branch for bioperl - but you would have to be using Ensembl in
mind numbing detail to notice the difference).  At the moment, most
but certainly not all, of Ensembl will work with the forthcoming 0.7
series of bioperl, and it will throw alot of warnings. To download, again you can
use cpan with ``install bioperl-0.6.2.tar.gz''. If you are reading this document past Ensembl0.8
you'll have to root around on our web pages to see which bioperl to use with the Ensembl you aim
to download.
\end{description}

Apologies for the number of external packages to install. This is I'm afraid to say 
par for the course for this sort of project.

You are now ready to download Ensembl. You have two basic options of what to download.
(a) Download a tar file of the code which is synchronised with an Ensembl data release.
You will find this in ftp://ftp.ensembl.org/pub/current/software/ (b) Download the leading edge
version using anonymous cvs. The cvs repository is cvs.sanger.ac.uk, username cvs, password
CVSUSER (case important). You want to check out the ensembl module 

If anonymous cvs makes no sense to you, go for the tar ball.

Poke your nose into the ensembl directory. You should have a number of directories there, being
modules, scripts, docs and other stuff. You want to cd into modules. This is a top level 
perl modules directory. Go ``perl Makefile.PL'' followed by ``make test''. This will run the
Ensembl test system.

The Ensembl test systems fails for 3 main reasons.

\begin{description}
\item[No Bioperl] Phenotype: Could not find Bio::Root::RootI in @ISA. You have not installed Bioperl
(see above!). Alternatively make sure Bioperl is in your PERL5LIB.
\item[No DBI/MySQL DBD] Phenotype: Could not find DBI in @ISA. You have not installed DBI or the
MySQL DBD drivers. See above 

\item[No permissions on local MySQL]
Phenotype DBI connect failed: Unknown MySQL Server Host localhost not
found.  

\end{description} 

The first two is just your error. The third is more understandable. Ensembl needs to connect to 
a local mysql to run tests (it loads and dumps mini mysql databases for testing purposes). By
default it connects to localhost mysql as user root with no password. This is a bad - but default -
connection protocol!

To change this copy the file in modules/t called
EnsTestDB.conf.example to EnsTestDB.conf (also in modules/t), and edit
the configuration to match your system: in particular you want to
connect to a database as a user that has drop and create database
priviledges. The EnsTestDB.pm module will create a unique database
name for each test, so you need not worry about it ``trashing'' other
pieces of information.

When the test system runs, it will output alot of stuff to the terminal, but hopefully say
``All Tests Successful'' at the end. It is really worth getting the test system to run, as then you
will be confident that Ensembl actually works on your system as you embark on more complex processes.

\section{First script}

The first script we'll write is to dump the underlying DNA fragments which make an assembly out
as fasta format. What we'll use as a database is one of the mini-tests databases used by the testing
system. The good thing about this is that (a) they are small (b) they are present in the source
distribution - no need to worry about downloading additional information and (c) they are guarenteed
to be working with the source code you have.

First we need to build the database, which we will call test\_ensembl

\begin{description}
\item[create a test database]. Either go ``mysqladmin -u user\_who\_can\_create create test\_ensembl'' or open
a mysql terminal window with ``mysql -u user\_who\_can\_create'' and go ``create database test\_ensembl''
in the terminal window
\item[load the schema]. The schema is kept in sql/table.sql. View the file if you are interested:
these SQL ``create table'' syntax is called the DDL of the database, or the schema, and provides the 
definition of the structure of the database. Go ``mysql -u user\_who\_can\_write test\_ensembl < sql/table.sql''
\item[load the database]. We'll use the staticgoldenpath.dump mini-database found in modules/t directory.
Again view the file if you are interested. The ``insert'' statements here put data into the database. Go
``mysql -u user\_who\_can\_write test\_ensembl < modules/t/staticgoldenpath.dump''
\end{description}

We are now ready for our first script (finally!)

\begin{verbatim}

#!/usr/local/bin/perl

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;


# this will die if if can't load this database
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::DBAdaptor/host=localhost;user=read_only_user;dbname=test_ensembl');

# build seqio output stream

$seqout = Bio::SeqIO->new( '-format' => fasta, '-fh' => \*STDOUT);

# get out all the accession numbers (clone ids) for
# sequences in this database

@clones = $db->get_all_Clone_id();


# for each clone_id, get the clone
foreach $clone_id ( @clones ) {
	$clone = $db->get_Clone($clone_id);
	foreach $fragment ( $clone->get_all_Contigs() ) {
		$seqout->write_seq($fragment);
   	}
}

\end{verbatim}

To explain this in more detail:

\begin{verbatim}

#!/usr/local/bin/perl

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;

\end{verbatim}

This loads up the necessary Perl modules. Only one Perl module for Ensembl is needed: DBLoader.
DBLoader will at run time load up the modules required for loading the database of choice

\begin{verbatim}
# this will die if if can't load this database
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::Obj/host=localhost;user=read_only_user;dbname=test_ensembl');
\end{verbatim}

This connects to the actual database. The string used for DBLoader is a sort of combined software+location
string. The first part indicates that the Bio::EnsEMBL::DBSQL::Obj is the software module which will
negotiate the Ensembl objects from the database. The remainder are parameters used in that modules
construction, in this case the host, user and dbname of the database

\begin{verbatim}
$seqout = Bio::SeqIO->new( '-format' => fasta, '-fh' => \*STDOUT);
\end{verbatim}

This builds a standard Bioperl output stream. In this case to Fasta format to stdout.

\begin{verbatim}
@clones = $db->get_all_Clone_id();


# for each clone_id, get the clone
foreach $clone_id ( @clones ) {
	$clone = $db->get_Clone($clone_id);
	foreach $fragment ( $clone->get_all_Contigs() ) {
		$seqout->write_seq($fragment);
   	}
}
\end{verbatim}

This is the real guts of the system. For each id, it is making a Clone
object with the call ``\$db->get\_Clone''. In Ensembl a Clone is
really a single sequence entry from EMBL/GenBank. For draft
(unfinished) cases, these are split up into a series of pieces of
contiguous DNA, called ``RawContigs'' in Ensembl terminology. Each
``RawContig'' implements the Bio::SeqI interface of bioperl, meaning
that standard bioperl methods (including dump to flat files) work
fine.


It is a pretty simple case to do a pretty simple task. 

\section{Ensembl Cookbook}


It is probably easier to explain how to use Ensembl by example than going
through the objects first off. Hence the Ensembl cookbook first, followed by 
a more in depth explanation of the objects.

Nearly all scripts follow the same basic pattern

\begin{itemize}
\item get hold of the root dbadaptor 
\item get hold of the Ensembl objects 
\item manipulate them and/or dump them
\end{itemize} 


\subsection{Dump all Protein translations of genes}

\begin{verbatim}

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;

$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::DBAdaptor/host=localhost;user=read_only_user;dbname=test_ensembl');

# build seqio output stream

$seqout = Bio::SeqIO->new( '-format' => fasta, '-fh' => \*STDOUT);

@genes = $db->get_all_Gene_id()

foreach $geneid ( @genes ){
      $gene = $db->get_Gene($geneid);
      foreach $trans ( $gene->each_Transcript ) {
          my $pep = $trans->translate();
          # pep is a SeqI compliant object
          $seqout->write_seq($pep);
      }
}

\end{verbatim}

Genes are collections of Transcripts. Each Transcript has one unique
translation. Inside the schema, two Transcripts can share the same
peptide (translation), but the object model does not nicely handle
this. At the moment, Transcripts are only predicted when they have
different peptides (translations).

Notice that getting out these gene objects does not require any
assembly information - we just get the genes out ``directly'' from the
database, irregardless about how the assembly works.

At the moment this is working through the old-style ``central
DBAdaptor'' scheme. In the future we will get out the GeneAdaptor
object and then get the genes out from there. See section \ref{new_adaptor}
for more information about the new adaptor scheme.


\subsection{Dump a region of a chromosome}

This requires access to assembly information. Ensembl can switch
between different assemblies from the same set of underlying DNA
fragments - however in general Ensembl is only distributed with
one assembly. With the object layer one has still indicate which
assembly ``type'' is used - generally this is ``UCSC'' as we use
the assemblies from UCSC.


\begin{verbatim}

use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;


$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::DBAdaptor/host=localhost;user=read_only_user;dbname=test_ensembl');

# set the assembly type. Ensembl can store multiple assemblies
# concurrently, although in general the gene prediction data will
# only be in sync with one of the assemblies

$db->static_golden_path_type('UCSC');

# get out the staticgoldenpathadaptor. This might be better called
# the virtual contig adaptor

$sadp = $db->get_StaticGoldenPathAdaptor();

# A virtualcontig is a slice of the assembly.

my $vc = $sadp->fetch_VirtualContig_chr_start_end('chr12',10000,20000);

my $seqout = Bio::SeqIO->new( -format => 'fasta',-fh => \*STDOUT);

# write out the virtual contig. $vc is a Bio::SeqI compliant object
# so we can write out it out to a SeqIO stream

$seqout->write_seq($vc);

# alternatively we can get the sequence as a string

$seqstring = $vc->seq();

\end{verbatim}

This script introduces the idea of ``VirtualContigs''. A virtual contig is a
slice of an assembly. A virtual contig can be anything from one tiny piece
of an assembly through to an entire chromosome. (Virtual Contigs are also used
for weirder dumping, including dumping regions via ``clone'' coordinates).

Whatever route to get a virtual contig, one always get the same sort
of object.  The Virtual Contig is-a sequence, with coordinates
starting at one. All the Sequence features (but for genes) you get out
on it are converted to the coordinates of the virtual contig, for example,
starting from one. 

As Virtual Contigs inheriet from Bio::SeqI anything which you can do
with ``standard'' bioperl objects you can do with a virtual contig. In
general you'll wont want to do so much with standard bioperl calls
(such as \$seq->top\_SeqFeatures), but use the more specific Ensembl
calls (such as \$vc->get\_all\_SimilarityFeatures).

One thing which is very different to get are Genes, as Gene does
not inheriet from SeqFeatureI.


\subsection{Dump 50bp around exons of a gene}

This is a more complex operation as the 50bp is now dependent on the
assembly of the genome - a particular exon could be right near a
``switch point'' where the assembly changes from one fragment to the
next (see section \ref{assembly_info} for more information about
assemblies). We have to get a gene out in the context of an assembly.



\begin{verbatim}
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::DBAdaptor/host=localhost;user=read_only_user;dbname=test_ensembl');

# we expect a gene id as the argument to this script
my $geneid = shift;


# set the assembly type. Ensembl can store multiple assemblies
# concurrently, although in general the gene prediction data will
# only be in sync with one of the assemblies

$db->static_golden_path_type('UCSC');

# get out the staticgoldenpathadaptor. This might be better called
# the virtual contig adaptor

$sadp = $db->get_StaticGoldenPathAdaptor();

# get a VirtualContig around this gene. The 100 is how much
# upstream and downstream from the first and last exons we
# should take

$vc = $sadp->fetch_VirtualContig_of_gene($geneid,100);

# frustratingly here we have now a slice of the genome with our gene
# of interest on it - however there may well be other genes in this
# region, including nested genes inside introns, etc etc.

# need to find ``our'' gene

my $found_gene;

foreach $gene ( $vc->get_all_Genes() ) {
	if( $gene->id eq $geneid ) {
            $found_gene = $gene;
        }
}

if( !defined $found_gene ) {
   die('no gene of interest... on vc. Bad error');
}

# when we get genes on a virtualcontig, the coordinates of the exon are
# magically converted to be relevant to this virtual contig.

foreach $trans ( $found_gene->each_Transcript ) {
 foreach $exon ( $trans->each_Exon ) {

  # there is the theoretical chance that an exon
  # does not lie on this virtualcontig. This would happen
  # when the gene was built on a different assembly from
  # the asembly used to extract them.

  # if the exon is not on the virtual contig, the seqname
  # will not be the same as the virtual contig id

  if( $exon->seqname ne $vc->id ) {
    next;
  }

  if( $exon->strand == 1 ) {
    print " exon ",$exon->id,"  ",$vc->subseq($exon->start-50,$exon->end+50),"\n";
  } else {
    # if we wanted just the sequence of the exon, 
    # $exon->seq would give it to us fine. However we want 50bp each
    # way around

    # no easy way to dump reverse complement. trunc gives us back a Bio::PrimarySeqI
    # object of this region, revcom reverse complements it and seq is the actual sequence
    # this is a little convoluted. 
    print " exon ",$exon->id,"  ",
          $vc->trunc($exon->start-50,$exon->end+50)->revcom->seq,
          "\n";
  }
 }
}

\end{verbatim}

\subsection{Dump rich tab delimited format for one chromosome}

\begin{verbatim}
$db = Bio::EnsEMBL::DBLoader->new('Bio::EnsEMBL::DBSQL::DBAdaptor/host=localhost;user=read_only_user;dbname=test_ensembl');

# set the assembly type. Ensembl can store multiple assemblies
# concurrently, although in general the gene prediction data will
# only be in sync with one of the assemblies

$db->static_golden_path_type('UCSC');

# get out the staticgoldenpathadaptor. This might be better called
# the virtual contig adaptor

$sadp = $db->get_StaticGoldenPathAdaptor();

# get a virtual contig of the chromosome. This call will take
# a while (30 seconds or so) to complete

$vc = $sadp->fetch_VirtualContig_by_chr_name('chr10');

# dump start,end,strand,type,score,external-identifier

# dump similarity features - mainly BLAST results

foreach $sim ( $vc->get_all_SimilarityFeatures ) {
  print STDOUT join('\t',$sim->start,$sim->end,$sim->strand,$sim->score,$sim->hseqname),"\n";
}

# dump repeats

foreach $rep ( $vc->get_all_RepeatFeatures ) {
  print STDOUT join('\t',$rep->start,$rep->end,$rep->strand,$rep->score,$rep->hseqname),"\n";
}

# dump genes. We'll dump as exons with Transcript id's as the external-identifier

foreach $gene ( $vc->get_all_Genes ) {
  foreach $trans ( $gene->each_Transcript ) {
     foreach $exon ( $trans->each_Exon ) {
       print STDOUT join('\t',$exon->start,$exon->end,$exon->strand,$exon->score,$trans->id),"\n";
     }
  }
}

\end{verbatim}

\section{Ensembl and Bioperl objects}

Many Ensembl objects inheriet from Bioperl Interface definitions; they
therefore comply to those interfaces and then extend them in Ensembl
specific ways. The implementation of the objects in general is
\emph{radically} different - most bioperl objects for example just
store everything in a Perl hash, whereas many Ensembl objects are a
Perl hash with minimal information (mainly the primary key of object
in the database) and also access to the underlying database. In these
cases, methods trigger a quick trip to the database to retrieve the
objects of interest.

This section has been grouped by the type of Bioperl object the Ensembl
object extends and gives you a quick overview of how to use the methods

\subsection{Bio::SeqI compliant objects}

Bio::SeqI is the bioperl ``heavy'' sequence object, containing the
sequence, identifiers and 

\end{document}







