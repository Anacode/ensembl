# check clone versions and splits in DB against AGP
# report which are mismatched
# usage: check_clones_against_agp -db_options < AGP

# loads clone/split info from AGP
# checks that each is in ensembl database
# for those that are, checks that split is compatible
# - ensembl golden clone (in AGP) lies within an
#   ensembl contig
# - each ensembl contig is used no more than once


use strict;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Getopt::Long;

my ($db, $host, $user, $pass);
my ($opt_ok, $help);
my %golden_clones;

$Getopt::Long::autoabbrev = 0;
$Getopt::Long::ingorecase = 0;


$opt_ok = &GetOptions(
    'db|d:s'   => \$db,
    'user|u:s' => \$user,
    'pass|p:s' => \$pass,
    'host|h:s' => \$host,
    'help|H'   => \$help
);

if ($help) {
    &usage;
    exit 0;
}

unless ($db && $user && $host) {
    print STDERR "Minimum arguments: database name, host and user\n\n";
    &usage;
    exit 1;
}


my $dbh = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
	 -dbname => $db,
	 -host   => $host,
	 -user   => $user,
	 -pass   => $pass
) or die "Can't connect to DB $db:$host:$user";

my $ca = $dbh->get_CloneAdaptor;


# scan AGP file and store clone and fragment coords
while (<>) {
    chomp;

    my ($tag, $sv, $start, $end) = (split)[4, 5, 6, 7];
    next if $tag eq 'N';

    push @{$golden_clones{$sv}}, [ $start, $end ];
}


# check clones in golden path vs ensembl versions
foreach my $sv (keys %golden_clones) {

    my ($ens_clone);
    my ($acc, $ver) = $sv =~ /(\S+)\.(\d+)/;
    eval {
	$ens_clone = $ca->fetch_by_accession_version($acc, $ver);
    };
    if ($@) {
	print "Not found $sv\n";
	next;
    }

    # store contigs for ensembl clone as list of start, end
    my @ens_contigs = map {
	[ $_->embl_offset, $_->embl_offset + $_->length - 1 ]
    } @{$ens_clone->get_all_Contigs};

    # retrieve list of start,end for golden clones
    my @golden_contigs = @{$golden_clones{$sv}};

    my %match;

    # store matches between two contig sets
    foreach my $golden_contig (@golden_contigs) {
	my ($golden_start, $golden_end) = @$golden_contig;

        foreach my $ens_contig (@ens_contigs) {
	    my ($ens_start, $ens_end) = @$ens_contig;

	    if ($golden_start >= $ens_start && $golden_end <= $ens_end) {
		$match{$golden_start} = $ens_start;
	    }
        }
    }

    # have all golden contigs been matched to ensembl?
    if (scalar @golden_contigs == scalar keys %match) {

	# each ensembl contig must hit a different golden contig
	# - are all the matched contigs different?
	my %unq_golden_matches = map { $_, 1 } values %match;
	if (scalar keys %unq_golden_matches == scalar keys %match) {
	     print "OK $sv\n";
	}

	# if not, we have >1 ensembl contig for the same
	# golden fragment (not allowed)
	else  {
	     print "Mismatch for $sv (non-unique ensembl contigs)\n";
	}
    }

    # Not all golden fragments have been matched
    else {
	print "Mismatch for $sv\n";
    }
}


sub usage {
    print <<EOF
Usage: $0 -db <name> -host <host> -user <user> < <NCBI AGP file>
EOF
}

