# compare existing ensembl mappings with those generated by new xref mapper

# files should be in format
# xref_accession ensembl_type ensembl_id

# to dump this from an ensembl datbase use something like
# mysql -u ensro -h ecs2 -P 3365 -e "select x.dbprimary_acc, ox.ensembl_object_type, ox.ensembl_id from xref x, object_xref ox, external_db edb where edb.db_name like 'Uniprot/SWISSPROT' and x.external_db_id=edb.external_db_id and x.xref_id=ox.xref_id order by x.xref_id" homo_sapiens_core_25_34e > ensembl_swissprot_translations.txt

use strict;

use Getopt::Long;

my ( $old, $new, $pass, $port, $dbname  );

GetOptions( "old=s", \$old,
	    "new=s", \$new);

if( !($old && $new) ) {
  usage();
  exit(1);
}

# read files into xref/object hashes
# TODO - more than one mapping?

my ($new_x2e_r, $new_e2x_r) = read_mappings($new);
my ($old_x2e_r, $old_e2x_r)  = read_mappings($old);

my %new_x2e = %$new_x2e_r;
my %old_x2e = %$old_x2e_r;
my %new_e2x = %$new_e2x_r;
my %old_e2x = %$old_e2x_r;

# ----------------------------------------
# Compare mappings keyed on xref

my ($matched, $mismatched, $new_only, $old_only, $total);

foreach my $xref_id (keys %new_x2e) {

  # if a mapping exists, look for any matches
  my $found = 0;
  if (exists $old_x2e{$xref_id}) {
    foreach my $old_value (@{$old_x2e{$xref_id}}) {
      foreach my $new_value (@{$new_x2e{$xref_id}}) {
	if ($old_value eq $new_value) {
	  $found = 1;
	}
      }
    }
    $found ? $matched++ : $mismatched++;
    $total++;

  } else {
    $new_only++;
  }

}

foreach my $xref_id (keys %old_x2e) {

  if (!exists $new_x2e{$xref_id}) {
    $old_only++;
  }

}

print "Compared " . scalar(keys %new_x2e) . " new xref mappings with " . scalar(keys %old_x2e) . " existing ensembl mappings\n";

print "\nComparing by xref:\n\n";

my $fmt = "%-30s\t%6d\t%5s%%\n";
printf $fmt, "Mapped with same result:", $matched, pc($matched, $total);
printf $fmt, "Mapped with different result:", $mismatched, pc($mismatched, $total);
printf $fmt, "Total mapped:", $total, pc($total, $total);

print "\nNumber mapped by new method only: $new_only\n";
print "Number mapped by old method only: $old_only\n";

# ----------------------------------------------------------------------

sub pc {

  my ($a, $total) = @_;
  my $number = 100 * $a / $total;
  my $pad = "";
  $pad .= " " if ($number < 100);
  $pad .= " " if ($number < 10);

  return $pad . sprintf "%3.2f", $number;

}

sub usage {

print << "EOF";

Usage: compare_mapping.pl -old <old mapping file> -new <new mapping file>

Mapping files should be in the following format:

xref_accession ensembl_type ensembl_id

EOF

}


sub read_mappings {

  my $filename = shift;
  my $i = 0;

  my %xref_to_ensembl;
  my %ensembl_to_xref;

  open (FILE, $filename) || die "Can't read $filename\n";
  my $dummy = <FILE>; # skip first line

  while(<FILE>) {

    my ($xref_id, $type, $ensembl_id) = split;
    # TODO - better way of handling type?
    my $value = $ensembl_id . "." . $type;
    push @{$xref_to_ensembl{$xref_id}}, $value;

    $ensembl_to_xref{$value} = $xref_id; # TODO map of lists
    $i++;

  }

  close(FILE);

  print "Read $i mappings from $filename\n";

  return (\%xref_to_ensembl, \%ensembl_to_xref);

}
