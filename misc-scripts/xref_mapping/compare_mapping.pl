# compare existing ensembl mappings with those generated by new xref mapper

# files should be in format
# xref_accession ensembl_type ensembl_id

# to dump this from an ensembl datbase use something like
# mysql -u ensro -h ecs2 -P 3365 -e "select x.dbprimary_acc, ox.ensembl_object_type, ox.ensembl_id from xref x, object_xref ox, external_db edb where edb.db_name like 'Uniprot/SWISSPROT' and x.external_db_id=edb.external_db_id and x.xref_id=ox.xref_id order by x.xref_id" homo_sapiens_core_25_34e > ensembl_swissprot_translations.txt

use strict;

use Getopt::Long;

my ( $old, $new, $pass, $port, $dbname  );

GetOptions( "old=s", \$old,
	    "new=s", \$new);

if( !($old && $new) ) {
  usage();
  exit(1);
}

# read files into xref/object hashes
# TODO - more than one mapping?

my %new_mappings = read_mappings($new);
my %ensembl_mappings = read_mappings($old);

compare_mappings(\%new_mappings, \%ensembl_mappings);

sub read_mappings {

  my $filename = shift;
  my $i = 0;

  my %mappings;

  open (FILE, $filename) || die "Can't read $filename\n";
  my $dummy = <FILE>; # skip first line

  while(<FILE>) {

    my ($xref_id, $type, $ensembl_id) = split;
    # TODO - better way of handling type?
    $mappings{$xref_id} = $type . "." . $ensembl_id;
    $i++;

  }

  close(FILE);

  print "Read $i mappings from $filename\n";

  return %mappings;

}

sub compare_mappings {

  my ($new_hashref, $ensembl_hashref) = @_;

  my %new_mappings = %$new_hashref;
  my %ensembl_mappings = %$ensembl_hashref;

  my ($matched, $mismatched, $new_only, $ensembl_only, $total);

  foreach my $xref_id (keys %new_mappings) {

    if (exists $ensembl_mappings{$xref_id}) {
      if ($ensembl_mappings{$xref_id} eq $new_mappings{$xref_id}) {
	$matched++;
      } else {
	$mismatched++;
      }
    } else {
      $new_only++;
    }

    $total++;

  }

 foreach my $xref_id (keys %ensembl_mappings) {

    if (!exists $new_mappings{$xref_id}) {
      $ensembl_only++;
    }

  }

  print "Compared " . scalar(keys %new_mappings) . " new xref mappings with " . scalar(keys %ensembl_mappings) . " existing ensembl mappings\n\n";

  my $fmt = "%-30s\t%6d\t%3.2f%%\n";
  printf $fmt, "Mapped with same result:", $matched, pc($matched, $total);
  printf $fmt, "Mapped with different result:", $mismatched, pc($mismatched, $total);
  printf $fmt, "Mapped by new method only:", $new_only, pc($new_only, $total);
  printf $fmt, "Total of new xrefs compared", $total, pc($total, $total);

  print "\nNumber mapped by old method only: $ensembl_only\n";


}

sub pc {

  my ($a, $total) = @_;
  return 100 * $a / $total;

}

sub usage {

print << "EOF";

Usage: compare_mapping.pl -old <old mapping file> -new <new mapping file>

Mapping files should be in the following format:

xref_accession ensembl_type ensembl_id

EOF

}
