#include "artemis-db-mysql.h"
#include <stdio.h>

/*
 * This is the implementation specific structure for an
 * ensembl-artemis database and the functions around this. Most of
 * this file is boiler plate implementation generated by orbit-idl's
 * skeleton implementation. The meat of this is held in lower down this file
 * 
 */

typedef struct
{
  POA_Ensembl_artemis_DB servant;
  PortableServer_POA poa;
  MYSQL * connection; /* connection to the ensembl database */
  int verbose; /* talk to stderr or not? */
} impl_POA_Ensembl_artemis_DB;

static void impl_Ensembl_artemis_DB__destroy(impl_POA_Ensembl_artemis_DB *
					     servant, CORBA_Environment * ev);
static Ensembl_artemis_Entry
impl_Ensembl_artemis_DB_getEntry(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_char * entryname,

				 CORBA_Environment * ev);

static Ensembl_artemis_EntryNameList
   *impl_Ensembl_artemis_DB_getallEntryNames(impl_POA_Ensembl_artemis_DB *
					     servant, CORBA_Environment * ev);


static PortableServer_ServantBase__epv impl_Ensembl_artemis_DB_base_epv = {
   NULL,			/* _private data */
   NULL,			/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Ensembl_artemis_DB__epv impl_Ensembl_artemis_DB_epv = {
   NULL,			/* _private */
   (gpointer) & impl_Ensembl_artemis_DB_getEntry,

   (gpointer) & impl_Ensembl_artemis_DB_getallEntryNames,

};

/*** vepv structures ***/

static POA_Ensembl_artemis_DB__vepv impl_Ensembl_artemis_DB_vepv = {
   &impl_Ensembl_artemis_DB_base_epv,
   &impl_Ensembl_artemis_DB_epv,
};

/*** Stub implementations ***/


static Ensembl_artemis_DB
impl_Ensembl_artemis_DB__create(PortableServer_POA poa,
				CORBA_Environment * ev)
{
   Ensembl_artemis_DB retval;
   impl_POA_Ensembl_artemis_DB *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Ensembl_artemis_DB, 1);
   newservant->servant.vepv = &impl_Ensembl_artemis_DB_vepv;
   newservant->poa = poa;
   POA_Ensembl_artemis_DB__init((PortableServer_Servant) newservant, ev);
   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

/*** INTERESTING STUFF from now on ***/

/*
 * This is the only publically visible function. It builds a new
 * implementation, registers it with the ORB and gives back the object
 * reference to the caller, which can do what it likes with it ;)
 */

Ensembl_artemis_DB new_EA_Database(PortableServer_POA poa,MYSQL * connection,int verbose,CORBA_Environment * ev)
{
   Ensembl_artemis_DB retval;
   impl_POA_Ensembl_artemis_DB *newservant;
   PortableServer_ObjectId *objid;


   g_assert(connection);

   newservant = g_new0(impl_POA_Ensembl_artemis_DB, 1);
   newservant->servant.vepv = &impl_Ensembl_artemis_DB_vepv;
   newservant->poa = poa;
   newservant->connection = connection;
   newservant->verbose = verbose;
   POA_Ensembl_artemis_DB__init((PortableServer_Servant) newservant, ev);
   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   if( newservant->verbose ) {
     fprintf(stderr,"DB: Making a new database with verbose flag set\n");
   }

   return retval;
}
  
static void
impl_Ensembl_artemis_DB__destroy(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_Environment * ev)
{
   PortableServer_ObjectId *objid;

   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
   CORBA_free(objid);

   POA_Ensembl_artemis_DB__fini((PortableServer_Servant) servant, ev);
   g_free(servant);
}

/*
 * This function delegates all its hard work to the
 * new_Ensembl_artemis_Entry function in the artemis-mysql-impl.c
 * function. That is where the bulk of the processing occurs
 */
static Ensembl_artemis_Entry
impl_Ensembl_artemis_DB_getEntry(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_char * entryname,
				 CORBA_Environment * ev)
{
   Ensembl_artemis_Entry retval;

   char sqlbuffer[1024];
   MYSQL_RES * result;
   MYSQL_ROW row;
   int state;

   if( servant->verbose ) {
     fprintf(stderr,"DB: Going to make a new entry with entryname %s\n",entryname);
   }

   retval = new_Ensembl_artemis_Entry(servant->poa,servant->connection,g_strdup(entryname),ev);

   if( servant->verbose ) {
     fprintf(stderr,"DB: Made new entry with entryname %s\n",entryname);
   }


   return retval;
}

/*
 * Pretty simply loop over all entries in the clone table
 */

static Ensembl_artemis_EntryNameList *
impl_Ensembl_artemis_DB_getallEntryNames(impl_POA_Ensembl_artemis_DB *
					 servant, CORBA_Environment * ev)
{
   Ensembl_artemis_EntryNameList *retval;
   char sqlbuffer[1024];
   MYSQL_RES * result;
   MYSQL_ROW row;
   int state;
   int no,i;

   sprintf(sqlbuffer,"SELECT id from contig");
   state = mysql_query(servant->connection,sqlbuffer);
   result = mysql_store_result(servant->connection);

   no = mysql_num_rows(result);

   retval = CORBA_sequence_CORBA_string__alloc();
   retval->_buffer = (CORBA_char **) calloc(no,sizeof(CORBA_char *));
   retval->_length = no;
   retval->_maximum = no;
   
   i = 0;
   while( row= mysql_fetch_row(result) ) {
     retval->_buffer[i++] = CORBA_string_dup(row[0]);
   }

   

   return retval;
}
