#include "artemis-db-mysql.h"
#include "timetolease.h"
#include <stdio.h>

/*
 * This is the implementation specific structure for an
 * ensembl-artemis database and the functions around this. Most of
 * this file is boiler plate implementation generated by orbit-idl's
 * skeleton implementation. The meat of this is held in lower down this file
 * 
 */

typedef struct
{
  POA_Ensembl_artemis_DB servant;
  PortableServer_POA poa;
  MYSQL * connection; /* connection to the ensembl database */
  int verbose; /* talk to stderr or not? */
  SimpleObjectManagerAdaptor soma;
} impl_POA_Ensembl_artemis_DB;

static void impl_Ensembl_artemis_DB__destroy(impl_POA_Ensembl_artemis_DB *
					     servant, CORBA_Environment * ev);
static Ensembl_artemis_Entry
impl_Ensembl_artemis_DB_getEntry(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_char * entryname,

				 CORBA_Environment * ev);

static Ensembl_artemis_EntryNameList
   *impl_Ensembl_artemis_DB_getallEntryNames(impl_POA_Ensembl_artemis_DB *
					     servant, CORBA_Environment * ev);


static Ensembl_artemis_FeatureDefinitionList
   *impl_Ensembl_artemis_DB_getFeatureDefinitionList
   (impl_POA_Ensembl_artemis_DB * servant, CORBA_Environment * ev);

static CORBA_long
impl_Ensembl_artemis_DB_max_sequence_length(impl_POA_Ensembl_artemis_DB *
					    servant, CORBA_Environment * ev);

static PortableServer_ServantBase__epv impl_Ensembl_artemis_DB_base_epv = {
   NULL,			/* _private data */
   NULL,			/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Ensembl_artemis_DB__epv impl_Ensembl_artemis_DB_epv = {
   NULL,			/* _private */
   (gpointer) & impl_Ensembl_artemis_DB_getEntry,
   (gpointer) & impl_Ensembl_artemis_DB_getallEntryNames,
   (gpointer) & impl_Ensembl_artemis_DB_getFeatureDefinitionList,
};

/*** vepv structures ***/

static POA_Ensembl_artemis_DB__vepv impl_Ensembl_artemis_DB_vepv = {
   &impl_Ensembl_artemis_DB_base_epv,
   &impl_Ensembl_artemis_DB_epv,
};

/*** Stub implementations ***/


static Ensembl_artemis_DB
impl_Ensembl_artemis_DB__create(PortableServer_POA poa,
				CORBA_Environment * ev)
{
   Ensembl_artemis_DB retval;
   impl_POA_Ensembl_artemis_DB *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Ensembl_artemis_DB, 1);
   newservant->servant.vepv = &impl_Ensembl_artemis_DB_vepv;
   newservant->poa = poa;
   POA_Ensembl_artemis_DB__init((PortableServer_Servant) newservant, ev);
   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

/*** INTERESTING STUFF from now on ***/

/*
 * This is the only publically visible function. It builds a new
 * implementation, registers it with the ORB and gives back the object
 * reference to the caller, which can do what it likes with it ;)
 */

Ensembl_artemis_DB new_EA_Database(PortableServer_POA poa,MYSQL * connection,int verbose,SimpleObjectManagerAdaptor soma,CORBA_Environment * ev)
{
   Ensembl_artemis_DB retval;
   impl_POA_Ensembl_artemis_DB *newservant;
   PortableServer_ObjectId *objid;

   

   g_assert(connection);

   fprintf(stderr,"Going to build db object\n");

   newservant = g_new0(impl_POA_Ensembl_artemis_DB, 1);
   newservant->servant.vepv = &impl_Ensembl_artemis_DB_vepv;
   newservant->poa = poa;
   newservant->connection = connection;
   newservant->verbose = verbose;
   newservant->soma = soma;

   POA_Ensembl_artemis_DB__init((PortableServer_Servant) newservant, ev);
   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   if( newservant->verbose ) {
     fprintf(stderr,"DB: Making a new database with verbose flag set\n");
   }

   return retval;
}
  
static void
impl_Ensembl_artemis_DB__destroy(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_Environment * ev)
{
   PortableServer_ObjectId *objid;

   objid = PortableServer_POA_servant_to_id(servant->poa, servant, ev);
   PortableServer_POA_deactivate_object(servant->poa, objid, ev);
   CORBA_free(objid);

   POA_Ensembl_artemis_DB__fini((PortableServer_Servant) servant, ev);
   g_free(servant);
}

/*
 * This function delegates all its hard work to the
 * new_Ensembl_artemis_Entry function in the artemis-mysql-impl.c
 * function. That is where the bulk of the processing occurs
 */
static Ensembl_artemis_Entry
impl_Ensembl_artemis_DB_getEntry(impl_POA_Ensembl_artemis_DB * servant,
				 CORBA_char * entryname,
				 CORBA_Environment * ev)
{
   Ensembl_artemis_Entry retval;

   char sqlbuffer[1024];
   MYSQL_RES * result;
   MYSQL_ROW row;
   int state;


   retval = new_Ensembl_artemis_Entry(servant->poa,servant->connection,g_strdup(entryname),servant->soma,ev);
   if ((ev)->_major != CORBA_NO_EXCEPTION ) {
     return;
   }

   SimpleObjectManagerAdaptor_log_message(&servant->soma,0,"Made new entry with entryname %s\n",entryname);
   /*   show_alloc_blocks(stderr);*/

   return retval;
}

/*
 * Pretty simply loop over all entries in the clone table
 */

static Ensembl_artemis_EntryNameList *
impl_Ensembl_artemis_DB_getallEntryNames(impl_POA_Ensembl_artemis_DB *
					 servant, CORBA_Environment * ev)
{
   Ensembl_artemis_EntryNameList *retval;
   char sqlbuffer[1024];
   MYSQL_RES * result;
   MYSQL_ROW row;
   int state;
   int no,i;

   sprintf(sqlbuffer,"SELECT id from contig");
   state = mysql_query(servant->connection,sqlbuffer);
   result = mysql_store_result(servant->connection);

   no = mysql_num_rows(result);

   retval = CORBA_sequence_CORBA_string__alloc();
   retval->_buffer = (CORBA_char **) calloc(no,sizeof(CORBA_char *));
   retval->_length = no;
   retval->_maximum = no;
   
   i = 0;
   while( row= mysql_fetch_row(result) ) {
     retval->_buffer[i++] = CORBA_string_dup(row[0]);
   }

   

   return retval;
}

static Ensembl_artemis_FeatureDefinitionList *
impl_Ensembl_artemis_DB_getFeatureDefinitionList(impl_POA_Ensembl_artemis_DB *
						 servant,
						 CORBA_Environment * ev)
{
   Ensembl_artemis_FeatureDefinitionList *retval;

   retval = CORBA_sequence_Ensembl_artemis_FeatureDefinition__alloc();
   retval->_buffer = CORBA_sequence_Ensembl_artemis_FeatureDefinition_allocbuf(2);
   retval->_length = 2;
   retval->_maximum = 2;

   retval->_buffer[0].key = CORBA_string_dup("exon");
   retval->_buffer[0].qualifiers._buffer = CORBA_sequence_CORBA_string_allocbuf(3);
   retval->_buffer[0].qualifiers._length = 3;
   retval->_buffer[0].qualifiers._maximum = 3;
   retval->_buffer[0].qualifiers._buffer[0] = CORBA_string_dup("created");
   retval->_buffer[0].qualifiers._buffer[1] = CORBA_string_dup("modified");
   retval->_buffer[0].qualifiers._buffer[2] = CORBA_string_dup("exon_id");

   retval->_buffer[0].key = CORBA_string_dup("mRNA");
   retval->_buffer[0].qualifiers._buffer = CORBA_sequence_CORBA_string_allocbuf(1);
   retval->_buffer[0].qualifiers._length = 1;
   retval->_buffer[0].qualifiers._maximum = 1;
   retval->_buffer[0].qualifiers._buffer[0] = CORBA_string_dup("transcript_id");

   return retval;
}










