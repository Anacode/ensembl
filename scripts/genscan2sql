#!/usr/local/bin/perl -w

BEGIN {
  unshift (@INC,"/home/michele/perl/humpub/modules/");
  unshift (@INC,"/home/michele/perl/humpub/modules/PerlModules");
}
use GFF;
use GeneFeature;

use strict;

foreach my $file (@ARGV) {
    my( $G,             # Fgene Set object
        $No_Gene_Flag,  # Set if no genes predicted
        $Version_Flag,  # Set if output being parsed matches $Genscan_Version
        );

    my $seqname;

    open GENSCAN, "<$file" or die "Can't open ('$file') for read : $!";
    while (<GENSCAN>) {
      if (/^Sequence +(\S+)/) {
	$seqname = $1;
	close(GENSCAN);
      }
    }

    unless ($seqname) {
      # Take off leading directories
      # we expect the filename to be of the form
      # dJ401P4.00741.gs
      # The id is dJ401P4.00741
      ($seqname = $file) =~ s/.*\/(.*\..*)\..*/$1/;
    }
      
    
    # Make a new object to store the data
    $G = Genscan->new( $seqname );
    
    # Parse genscan output
    open GENSCAN, "<$file" or die "Can't open ('$file') for read : $!";
    
  PARSE: while (<GENSCAN>) {
      my $version;
      
      # Header gives Genscan version
      if (/^GENSCAN\s*(\S+)/o) {
	$version = $1;
#	print "// $_\n";
      }
      
      # Last line before predictions contains nothing
      # but spaces and dashes
      if (/^\s*-[-\s]+$/) {
	
	while (<GENSCAN>) {
	  
	  next if /^$/;
	  
	  # If sequence is too short;
	  if (m|NO EXONS/GENES PREDICTED IN SEQUENCE|) {
	    $No_Gene_Flag = 1;
	    last PARSE;
	  };
	  
	  # End of genes section
	  last PARSE if /Predicted peptide/;
	  
	  my @l = split;
	  
	  my ($n) = $l[0] =~ /^(\d+)/;
	  
	  # Get the right gene from the set
	  my $gene = $G->gene( $n );
	  
	  # Is it an exon line?
	  if ( $l[1] =~ /^(Sngl|Init|Intr|Term)/ ) {
	    # Pass strand, start, stop to exons()
	    $gene->exons( @l[2,3,4] );
	  }
	  # or a Promoter?
	  elsif ( $l[1] =~ /^Prom/ ) {
	    $gene->prom( $l[3] );
	  }
	  # or a Poly-A?
	  elsif ( $l[1] =~ /^PlyA/ ) {
	    $gene->poly( $l[3] );
	  }
	  # Unknown line type
	  else {
	    chomp;
	    die "Unknown line type ('$_')";
	  }
	}
      }
    }
    close GENSCAN;
    
    if ($No_Gene_Flag) {
      print "\n// genscan did not find any genes\n\n";
    } else {
      # Output status from Genscan unreliable, so check
      # that we have predicted genes stored
      unless ($G->gene_count()) {
	die $! ? "Error running genscan ('$file') : $!"
	  : "Exit status ($?) from genscan ('$file')";
      }
      
      # Convert to GFF
      my $gff = $G->toGFF();
      my @lines = Genscan::toSQLfeatureset($gff);
      print("use pog\n");
      print(@lines);
      
    }
  }

exit;

      

# Output format of GENSCAN:
#
# GENSCAN 1.0     Date run: 12-Apr-99     Time: 17:08:27
# 
# Sequence dJ981L23 : 94817 bp : 41.52% C+G : Isochore 1 ( 0.00 - 43.00 C+G%)
# 
# Parameter matrix: HumanIso.smat
# 
# Predicted genes/exons:
# 
# Gn.Ex Type S .Begin ...End .Len Fr Ph I/Ac Do/T CodRg P.... Tscr..
# ----- ---- - ------ ------ ---- -- -- ---- ---- ----- ----- ------
# 
#  1.01 Intr +   3052   3191  140  0  2   66   86    96 0.538   5.54
#  1.02 Intr +  25169  25490  322  2  1    0   63   221 0.031   5.74
#  1.03 Term +  26023  26373  351  0  0  -32   36   296 0.805   5.90
#  1.04 PlyA +  26606  26611    6                               1.05
# 
#  2.00 Prom +  27134  27173   40                              -7.65
#  2.01 Init +  27464  27666  203  1  2   69   44   216 0.795  13.70
#  2.02 Intr +  29211  29322  112  0  1   85   57    79 0.779   3.96
#  2.03 Term +  35938  36069  132  0  0   78   46   191 0.861  11.01
#  2.04 PlyA +  36272  36277    6                               1.05
# 
#  3.00 Prom +  37608  37647   40                              -5.45
#  3.01 Init +  43809  43907   99  2  0   53   61   152 0.894   9.31
#  3.02 Term +  48720  48824  105  2  0   83   48    67 0.415  -0.37
#  3.03 PlyA +  49128  49133    6                               1.05
# 
#  4.06 PlyA -  49250  49245    6                               1.05
#  4.05 Term -  52960  52598  363  1  0    0   49   252 0.033   6.08
#  4.04 Intr -  53465  53072  394  1  1  -18   85   266 0.501   9.43
#  4.03 Intr -  54257  54135  123  1  0   91   58    78 0.393   3.88
#  4.02 Intr -  55414  55094  321  0  0   80   48   208 0.431  10.05
#  4.01 Init -  55833  55562  272  0  2   80   94   265 0.586  22.79
#  4.00 Prom -  56511  56472   40                             -11.24

#----------------------------------------------------------------------

package Genscan;
use Carp;

sub new {
    my $pkg = shift;
    my $seqName = shift;
    return bless {
	_SEQNAME => $seqName,
	_genes => {}
    }, $pkg;
}
sub seqname {
    my $set = shift;
    return $set->{'_SEQNAME'};
}
sub gene {
    my( $set, $geneNo ) = @_;
    unless ( $set->{'_genes'}{$geneNo} ) {
	$set->{'_genes'}{$geneNo} = $set->newGene();
    }
    return $set->{'_genes'}{$geneNo};
}
sub newGene {
    my( $set ) = @_;
    my $pkg = ref($set);
    return bless {
	_strand => '',
	_prom => '',
	_poly => '',
	_exons => [],
	}, $pkg;
}
sub prom {
    my $fgene = shift;
    @_ ? $fgene->{'_prom'} = shift : return $fgene->{'_prom'};
}
sub poly {
    my $fgene = shift;
    @_ ? $fgene->{'_poly'} = shift : return $fgene->{'_poly'};
}
sub exons {
    my $fgene = shift;
    if (@_) {
	my ($strand,
	    $start,
	    $stop) = @_;
	croak "Error: Too few arguments to exons method" unless $stop;
	unless ($fgene->{'_strand'}) {
	    if ($strand eq '+') {
		$fgene->{'_strand'} = 'w'; # Watson
	    } elsif ($strand eq '-') {
		$fgene->{'_strand'} = 'c'; # Crick
	    } else {
                die "Weird strand: $strand";
            }
	}
	push( @{$fgene->{'_exons'}}, $start, $stop );
    } else {
	if ( @{$fgene->{'_exons'}} % 2 ) {
	    croak "Error: Uneven number of exon positions";
	}
	return sort { $a <=> $b } @{$fgene->{'_exons'}};
    }
}

sub gene_count {
    my $set = shift;
    return scalar keys %{$set->{'_genes'}};
}

sub toGFF {
  my $set = shift;
  my $seqname = $set->seqname();
  my @gff;
  my $count = 0;

  foreach my $num ( sort { $a <=> $b } keys %{$set->{'_genes'}} ) {
    my $gene = $set->{'_genes'}{$num};
    my $strand;

    if ($gene->{'_strand'} eq 'w') {
      $strand = '+';
    } elsif ($gene->{'_strand'} eq 'c') {
      $strand = '-';
    } 
    
    my @pos = $gene->exons();
    my( $a, $b, $subName );
    
    $gff[$count] = new GFF;
    
    my $ecount = 0;

    while ( ($a, $b, @pos) = @pos ) {
      my $tmp = new GeneFeature();

      $tmp->seqname("$seqname.GENSCAN.$count.$ecount");
      $tmp->start($a);
      $tmp->end($b);
      $tmp->source('GENSCAN');
      $tmp->strand($strand);

      $gff[$count]->addGeneFeature($tmp);

      $ecount++;
    }

    $count++;
  }
  return \@gff;
}

sub toSQL {
  my ($gff) = @_;
  my @sqllines;
  my $date = '1999-05-21';
  my $gcount = 0;

  foreach my $gene (@$gff) {

    # Create gene sql
    my $geneid = $gene->{feature}[0]->seqname();
    $geneid =~ s/(.*)\..*$/$1/;

    # Extract clone and contig info;
    my $clone = $geneid;
    my $contig = $geneid;
    
    $clone =~ s/^(.*?)\..*/$1/;
    $contig =~ s/^(.*?\..*?)\..*/$1/;

    my $tmp;

    # Write contig info
    if ($gcount == 0) {
      $tmp = "insert into contig(id,clone) values(\'$contig\',\'$clone\');\n";
      push(@sqllines,$tmp);
    }

    # Write gene info
    $tmp = "insert into gene values(\'$geneid\',\'1.0\',\'$date\',\'$date\');\n";
    push(@sqllines,$tmp);
   
    # Now transcript 
    my $transcriptid = "$geneid.CDS.1";
    $tmp = "insert into transcript values(\'$transcriptid\',\'$geneid\');\n";
    push(@sqllines,$tmp);

    my $ecount = 1;
    foreach my $gf ($gene->eachGeneFeature()) {
      # Exon sql
      $tmp = "insert into exon values(\'" . $gf->seqname() . "\',\'$contig\',1,\'$date\',\'$date\'," .
	$gf->start . "," . $gf->end . ",\'" . $gf->strand . "\');\n";
      push(@sqllines,$tmp);

      # and the exon_transcript bridge
      $tmp = "insert into exon_bridge values(\'" . $gf->seqname(). "\',\'" . $transcriptid  . "\'," . 
	$ecount . ");\n";
      push(@sqllines,$tmp);
      $ecount++;
    }
    $gcount++;
  }
  return @sqllines;
}
	
sub toSQLfeatureset {
  # This takes a Genescan object and parses it into a
  # set of feature rows tied together with a featureset row
  my ($gff) = @_;
  my @sqllines;
  my $date = '1999-05-23';
  my $gcount = 0;
  
  foreach my $gene (@$gff) {
    
    # Create gene sql
    # the geneid is initially of the form
    # dJ401P4.00741.GENSCAN.1.2
    # i.e. 3rd exon of the 2nd gene (counting from 0)
    
    my $geneid = $gene->{feature}[0]->seqname();
    
    $geneid =~ s/(.*)\..*$/$1/;

    # Extract clone and contig info;
    my $clone = $geneid;
    my $contig = $geneid;
    my $featureset = $geneid;

    $clone =~ s/^(.*?)\..*/$1/;
    $contig =~ s/^(.*?\..*?)\..*/$1/;

    my $tmp;
    
    foreach my $gf ($gene->eachGeneFeature()) {
      # Exon sql
      
      $tmp = "insert into feature(id,contig,start,end,strand,featureset) values(\'" . 
	$gf->seqname() . 
	  "\',\'$contig\'," .
	    $gf->start . "," .
	      $gf->end . ",\'" . 
		$gf->strand . "\',\'" .
	       $featureset . "\');\n";

      push(@sqllines,$tmp);

      # featureset sql
      $tmp = "insert into featureset(feature,id) values(\'" . $gf->seqname() . 
	"\',\'$featureset\');\n";
      push(@sqllines,$tmp);
    }
    $gcount++;
  }
  return @sqllines;
}
	

1;
