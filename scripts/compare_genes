#!/usr/local/bin/perl -w

use strict;

use Bio::EnsEMBL::DBLoader;
use Bio::EnsEMBL::DBSQL::Obj;
use Bio::EnsEMBL::AceDB::Obj;
use Getopt::Long;
use Time::Local;

my $dbtype1 = 'rdb';
my $host1   = 'ensrv3';
my $dbname1 = 'ensembl08';
my $dbuser1 = 'ensro';
my $dbpass1 = '';
my $port1   = 3306;

my $dbtype2 = 'ace';
my $host2   = 'humsrv1';
my $dbname2 = '';
my $dbuser2 = '';
my $dbpass2 = '';
my $port2   = 310000;

my $infile  = '';
$| = 1;

&GetOptions( 'dbtype1:s'  => \$dbtype1,
	     'host1:s'    => \$host1,
	     'port1:n'    => \$port1,
	     'dbname1:s'  => \$dbname1,
	     'dbpass1:s'  => \$dbpass1,
	     'dbtype2:s'  => \$dbtype2,
	     'host2:s'    => \$host2,
	     'port2:n'    => \$port2,
	     'dbname2:s'  => \$dbname2,
	     'dbpass2:s'  => \$dbpass2,
	     'infile=s'   => \$infile,
	     );


# Beginning of script
my ($db1, $db2) = get_db_handles();
my ($clone1, $clone2) = get_cloneids($infile, @ARGV);
process_clones($clone1, $clone2);
# End of script


sub process_clones {
    my (@clone1, @clone2) = @_;

    for (my $i = 0; $i <= $#$clone1; $i++) {
        print("Processing clone 1: " . $clone1->[$i] . " and clone 2: " . $clone2->[$i] . "\n");
    
        eval {
            my $cl1    = $db1->get_Clone($clone1->[$i]);
            my $cl2    = $db2->get_Clone($clone2->[$i]);

            my @genes1 = $cl1->get_all_Genes();
            my @genes2 = $cl2->get_all_Genes();

            print(scalar(@genes1) . " genes on clone 1; " . scalar(@genes2)  . " genes on clone 2\n\n");

            # Go through each gene on contig 1 and find the overlaps with all the genes on contig2 
            my $count = 1;
            foreach my $gene1 (@genes1) {
                my ($over, $exact, $link, $miss, $geneover, $matched_bases) = find_overlaps($gene1, @genes2);
            
                print("Clone 1 gene $count overlaps with $geneover genes and $matched_bases " .
                    "base pairs of exons from clone 2\n");
            
                my $numexons = scalar($gene1->each_unique_Exon);
                print("Total no. exons:$numexons, Overlaps:$over, Exact overlaps:$exact, Links:$link, Missed:$miss\n");
                $count++;
            }
        };
    
        if ($@) {
            print(STDERR "Skipping " . $clone1->[$i] . "\t" . $clone2->[$i] . "\n$@\n");
        }
    }
}



sub find_overlaps {
    my ($gene1, @genes2) = @_;

    my @exons1 = $gene1->each_unique_Exon;
    @exons1 = sort { $a->start <=> $b->start } @exons1;

    my %exonoverhash;
    my %exonexacthash;
    my %linkhash;
    my %matchhash;
    my $geneoverlaps = 0;
    my $matchedbases = 0;

    foreach my $gene2 (@genes2) {
	my @exons2 = $gene2->each_unique_Exon;
 	   @exons2 = sort { $a->start <=> $b->start } @exons2;
        my $exonoverlap = 0;
        
	foreach my $ex1 (@exons1) {
       
	    # Intialise the hashes for this exon to indicate no overlaps, links or matches
            $exonoverhash{$ex1} = 0;
            $exonexacthash{$ex1} = 0;            
            $linkhash{$ex1} = 0;   
            $matchhash{$ex1} = -1;
             
            for (my $i = 0; $i < scalar(@exons2); $i++) {
                
                # This call increments the hashes as appropriate
                my $bases = overlap($ex1, $exons2[$i], $exonoverhash{$ex1}, $exonexacthash{$ex1});
		if ($bases) {
                    # If there's an overlap, set the matchhash for exon1 to the index of exon2
                    $matchhash{$ex1} = $i;
                    $exonoverlap = 1;
                    $matchedbases += $bases;
                }
	    }
	}

        # If there was at least one exonoverlap found between gene1 and this particular gene2 
        # increment geneoverlaps
        if ($exonoverlap == 1) {
            $geneoverlaps++;
        }
        

	# Tot up the matchhash to find confirmed links for this gene2
	for (my $i = 0; $i < scalar(@exons1); $i++) {
        
            if (($matchhash{ $exons1[$i] } != -1) && ($matchhash{ $exons1[$i + 1] } != -1)) {
                
                # If the difference between two consecutive matchhashes is 1 then the exons on gene2 
                # are also consecutive which is defined as a link.               
		if ( ( $matchhash{ $exons1[$i] } - $matchhash{ $exons1[$i + 1] } ) == 1 ) {
		    $linkhash{$exons1[$i]} = 1;
		}	
            }         
	}
    }


    # Now add up all the gene2 exons with at least one overlap, exact overlap or having a linkhash 
    # equal to 1. If the linkhash isn't 1 check that consecutive exons1 do have an overlap. If so
    # it's a missed link 
    my $overlap_num       = 0;
    my $exact_num         = 0;
    my $confirmedlinks    = 0;
    my $missedlinks       = 0;  

    my $count = 0;    
    foreach my $ex1 (@exons1) {
    
	if ($exonoverhash{$ex1} > 0) {
	    $overlap_num++;
	}
        
	if ($exonexacthash{$ex1} > 0) {
	    $exact_num++;
	}

	if ($linkhash{$ex1} == 1) {
	    $confirmedlinks++;
	} else {
        
	    if ($count < $#exons1) {
		if ($exonoverhash{$exons1[$count]} > 0 &&
		    $exonoverhash{$exons1[$count+1]} > 0) {
		    $missedlinks++;
		}
	    }
	}
	$count++;
    }

    return ($overlap_num, $exact_num, $confirmedlinks, $missedlinks, $geneoverlaps, $matchedbases);
}    



sub overlap {
    my ($exon1, $exon2, $overlap, $exact_overlap) = @_;
    
    if (($exon2->end   > $exon1->start && $exon2->start < $exon1->end) ||
        ($exon2->start < $exon1->end   && $exon2->end   > $exon1->start)) {
        
        $overlap++;
        my $left  = ($exon2->start - $exon1->start);
	my $right = ($exon1->end   - $exon2->end);
        my $overlapsize = $right - $left;
        
        # Only the magnitude is required
        if ($overlapsize < 0) {
            $overlapsize = -$overlapsize;
        }
        
        if ($left == 0 && $right == 0) {
            $exact_overlap++        
        }
        
        return $overlapsize;
    }

    return 0;
}



sub get_cloneids {
    my ($infile,@ARGV) = @_;

    my @clone1;
    my @clone2;

    if (defined($infile)) {
	open(IN,"<$infile");
	while (<IN>) {
	    chomp;
	    my ($tmp1,$tmp2) = split(' ',$_);   
	    push(@clone2,$tmp1);
	    push(@clone1,$tmp2);
	}
	close(IN);
    }
    while ($#ARGV > 0) {
	my $clone1 = shift @ARGV;
	my $clone2 = shift @ARGV;
	push(@clone1,$clone1);
	push(@clone2,$clone2);
    }
    return (\@clone1,\@clone2);
}



sub get_db_handles {
    my ($db1,$db2);

    if( $dbtype1 =~ 'ace' ) {
	$db1 = Bio::EnsEMBL::AceDB::Obj->new( -host => $host1, 
					      -port => $port1);
    } elsif ( $dbtype1 =~ 'rdb' ) {

	my $locator = "Bio::EnsEMBL::DBSQL::Obj/host=$host1;" .
  	              "port=3306;"      .
		      "dbname=$dbname1;"  .
		      "user=$dbuser1;"    .
		      "pass=$dbpass1";

	$db1 = Bio::EnsEMBL::DBLoader->new($locator);
	
    } else {
	die("$dbtype1 is not a good type (should be ace or rdb)");

    }

    if( $dbtype2 =~ 'ace' ) {
	$db2 = Bio::EnsEMBL::AceDB::Obj->new( -host => $host2,
					      -port => $port2);
    } elsif ( $dbtype2 =~ 'rdb' ) {
	my $locator = "Bio::EnsEMBL::DBSQL::Obj/host=$host2;" .
	              "port=$port2;"     .
		      "dbname=$dbname2;" . 
		      "user=$dbuser2;"   .
		      "pass=$dbpass2";

	$db2 = Bio::EnsEMBL::DBLoader->new($locator);

    } else {
	die("$dbtype2 is not a good type (should be ace or rdb)");
    }

    return ($db1,$db2);
}
