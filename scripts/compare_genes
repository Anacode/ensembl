#!/usr/local/bin/perl

use strict;

use Bio::EnsEMBL::DBLoader;
use Bio::EnsEMBL::DBSQL::Obj;
use Bio::EnsEMBL::AceDB::Obj;
use Getopt::Long;
use Time::Local;

my $dbtype1 = 'rdb';
my $host1   = 'obi-wan';
my $dbname1 = 'ensembl';
my $dbuser1 = 'ensro';
my $dbpass1 = undef;
my $port1   = 3306;

my $dbtype2 = 'ace';
my $host2   = 'humsrv1';
my $dbname2 = '';
my $dbuser2 = '';
my $dbpass2 = undef;
my $port2   = 310000;

my $infile  = '';
$| = 1;
&GetOptions( 'dbtype1:s'  => \$dbtype1,
	     'host1:s'    => \$host1,
	     'port1:n'    => \$port1,
	     'dbname1:s'  => \$dbname1,
	     'dbpass1:s'  => \$dbpass1,
	     'dbtype2:s'  => \$dbtype2,
	     'host2:s'    => \$host2,
	     'port2:n'    => \$port2,
	     'dbname2:s'  => \$dbname2,
	     'dbpass2:s'  => \$dbpass2,
	     'infile=s'   => \$infile,
	     );

my ($db1,$db2) = get_db_handles();

my ($clone1,$clone2) = get_cloneids($infile,@ARGV);
my $i = 0;

for ($i = 0; $i <= $#$clone1; $i++) {
    print("Processing clone " . $clone1->[$i] . " " . $clone2->[$i] . "\n");
    eval {
    my $cl1    = $db1->get_Clone($clone1->[$i]);
    my $cl2    = $db2->get_Clone($clone2->[$i]);

    my @genes1 = $cl1->get_all_Genes();
    my @genes2 = $cl2->get_all_Genes();

    print("Genes1 " . scalar(@genes1) . " genes2 " . scalar(@genes2)  . "\n");
    my $count = 1;

    foreach my $gene1 (@genes1) {
	my ($over,$exact,$link,$miss) = find_overlaps($gene1,@genes2);
	my $numexons                  = scalar($gene1->each_unique_Exon);

	print(" Gene2 $count :\t$numexons\t$over\t$exact\t$link\t$miss\n");
	$count++;
    }
    };
    if ($@) {
      print(STDERR "Skipping " . $clone1->[$i] . "\t" . $clone2->[$i] . "\n$@\n");
     }
}

sub find_overlaps {
    my ($gene1,@genes2) = @_;

    my @exons1 = $gene1->each_unique_Exon;
       @exons1 = sort { $a->start <=> $b->start } @exons1;

    my $overlap_num       = 0;
    my $exact_num         = 0;
    my $confirmedlinks    = 0;
    my $missedlinks       = 0;

    my %exonoverhash;
    my %exonexacthash;
    my %linkhash;

    my @matcharray;

    foreach my $gene2 (@genes2) {
	my @exons2 = $gene2->each_unique_Exon;
 	   @exons2 = sort { $a->start <=> $b->start } @exons2;

	my $count1 = 0;
	foreach my $ex1 (@exons1) {
	    my $count2 = 0;
	    foreach my $ex2 (@exons2) {
		my (@overlap) = overlap($ex1,$ex2);
		
		if ($overlap[0] == 1) {
		    $exonoverhash{$ex1}++;

		    if ($overlap[1] == 0 && $overlap[2] == 0) {
			$exonexacthash{$ex1}++;
		    }
		    
		    $matcharray[$count1] = $count2;
		}
		$count2++;
	    }
	    $count1++;
	}

	# Tot up the matcharray to find confirmed links
	for (my $i = 0; $i < scalar(@exons1); $i++) {
	    if ($matcharray[$i] != -1 && 
		$matcharray[$i+1] != -1) {

		if (($matcharray[$i+1] - $matcharray[$i]) == 1) {
		    $linkhash{$exons1[$i]} = 1;
		}
		
	    }
	}
	
    }

    # Now do the totting up over all gene2 genes
    my $count = 0;
    foreach my $ex1 (@exons1) {
	if ($exonoverhash{$ex1} > 0) {
	    $overlap_num++;
	}
	if ($exonexacthash{$ex1} > 0) {
	    $exact_num++;
	}

	if ($linkhash{$ex1} == 1) {
	    $confirmedlinks++;
	} else {
	    if ($count < $#exons1) {
		if ($exonoverhash{$exons1[$count]} > 0 &&
		    $exonoverhash{$exons1[$count+1]} > 0) {
		    $missedlinks++;
		}
	    }
	}
	$count++;
    }

    return ($overlap_num,$exact_num,$confirmedlinks,$missedlinks);
}    

sub overlap {
    my ($f1,$f2) = @_;
    my @overlap;
    
    if (($f2->end   > $f1->start && $f2->start < $f1->end) ||
        ($f2->start < $f1->end   && $f2->end   > $f1->start)) {

        #  we have an overlap so we now need to return
        #  two numbers reflecting how accurate the span
        #  is.
        #  0,0 means an exact match with the exon
        # a positive number means an over match to the exon
        # a negative number means not all the exon bases were matched

        my $left  = ($f2->start - $f1->start);
	my $right = ($f1->end   - $f2->end);

        push (@overlap,1);
        push (@overlap,$left);
        push (@overlap,$right);


    }

    return @overlap;
}

sub get_cloneids {
    my ($infile,@ARGV) = @_;

    my @clone1;
    my @clone2;

    if (defined($infile)) {
	open(IN,"<$infile");
	while (<IN>) {
	    chomp;
	    my ($tmp1,$tmp2) = split(' ',$_);
	    push(@clone2,$tmp1);
	    push(@clone1,$tmp2);
	}
	close(IN);
    }
    while ($#ARGV > 0) {
	my $clone1 = shift @ARGV;
	my $clone2 = shift @ARGV;
	push(@clone1,$clone1);
	push(@clone2,$clone2);
    }
    return (\@clone1,\@clone2);
}



sub get_db_handles {
    my ($db1,$db2);

    if( $dbtype1 =~ 'ace' ) {
	$db1 = Bio::EnsEMBL::AceDB::Obj->new( -host => $host1, 
					      -port => $port1);
    } elsif ( $dbtype1 =~ 'rdb' ) {

	my $locator = "Bio::EnsEMBL::DBSQL::Obj/host=$host1;" .
  	              "port=$port1;"      .
		      "dbname=ensembl;"  .
		      "user=$dbuser1;"    .
		      "pass=$dbpass1";

	$db1 = Bio::EnsEMBL::DBLoader->new($locator);
	
    } else {
	die("$dbtype1 is not a good type (should be ace or rdb)");

    }

    if( $dbtype2 =~ 'ace' ) {
	$db2 = Bio::EnsEMBL::AceDB::Obj->new( -host => $host2,
					      -port => $port2);
    } elsif ( $dbtype2 =~ 'rdb' ) {
	my $locator = "Bio::EnsEMBL::DBSQL::Obj/host=$host2;" .
	              "port=$port2;"     .
		      "dbname=$dbname2;" . 
		      "user=$dbuser2;"   .
		      "pass=$dbpass2";

	$db2 = Bio::EnsEMBL::DBLoader->new($locator);

    } else {
	die("$dbtype2 is not a good type (should be ace or rdb)");
    }

    return ($db1,$db2);
}
